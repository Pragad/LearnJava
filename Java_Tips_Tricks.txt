1. Why Java uses Heap instead of Stack
2. Access Specifiers
3. Early Binding
4. Object Base Class
5. What are Generics in Java
6. Heap and Stack Storage
7. How Garbage Collector Works
8. How JVM works
9. What is Escape Analysis:
10. Where objects are stored in Java
11. Hashtable HashMap LinkedHashMap TreeMap
11b. LinkedHashMap Complexity and Usage
12. How to make System.out.println() shorter
13. Using int vs Integer
13b. Using array vs ArrayList
14. How do I apply the for-each loop to every character in a String
15. Why can Java Collections not directly store Primitives types
16. Why is Java Vector class considered obsolete or deprecated
17. What is meant by immutable
18. Why is String immutable in Java
19. What does String Immutable mean
20. Combining charAt and IgnoreCasE
21. Adding Object to an ArrayList adds its reference
22. Java Constructors and Super Class
23. Exceptions
24. Final, Finally, Finalize
24b. Final in Java
25. How to find index of min element in a list
26. Get current date and time
27. Priority Queue peek, element, poll, remove
28. Priority Queue Offer vs Add
28b. Priority Queue Reverse Order:
29. for each loop in Java
30. Increment Value of a HashMap's Key
30b. Print All Key Value pairs of Hashmap in Java
30c. Add to an arraylist in HashMap
31. How to split a string in Java
32. Java String to Int and Int to String
33. Iterating over a Map using EntrySet
34. Signed Right Shift and Unsigned Right Shift
35. Method Variables and Class Variables with Final
36. Creating Java Objects
37. Why Java string does not need new to create
38. How are Java objects stored in memory
38b. When is memory allocated
39. Java Pass by value or Pass by reference
40. Check ArrayLists is empty
41. Check if Array is empty
42. Convert Array to ArrayList in Java
42a. How to convert int[] into List<Integer> in Java?
42b. Convert ArrayList to Array in Java
43. Integer MAX_VALUE
44. Char array to String
45. String to Char Array
46. Length Length() and Size()
47. How to use Iterator in Java
48. Generating Random Number
49. Using Synchronized in Java
50. Converting int to Integer and Integer to int
51. Iterator for LinkedHashMap
52. What are Packages
53. What is CLASSPATH
54. What is Strongly Typed / Weak Typed, Static Typed and Dynamic Typed Language
55. C++ Features Missing in Java
56. Java Main Class need not be Public
57. What is Volatile in Java
58. Can't use INT as Bool in condition
59. >>> and >>
60. try catch throw throws finally throwable
61. What is finalize
62. Create 2D Array in Java
63. Access Specifiers in Java
64. Find log base 2 of a number
65. Convert a char to an int or Get numeric value of a character
66. What is THIS
67. Java Heap Old gen, Perm Gen and Young gen
68. Declare array in Java
69. Boolean[] vs BitSet
70. ArrayList get set
71. Array and ArrayList pass reference by value
72. Change a character in a String
73. Java FileChannel - Java NIO
74. @Override
75. Get Boolean from a String
76. Try Catch Throws - Komprise
77. String concatenation for Logging {} vs +
78. Logging exception
79. How to fix Could not find or load main class error
80. Run class inside a jar, MVN Building app into JAR with all dependencies and running the app - Fat JAR
81. How to resolve Could not find or load main class Foo error
82. Print a list using forEach
83. How to convert Java String into byte[]?
83b. Convert integer into byte array (Java)
84. Is there an equivalent to memcpy() in Java?
85. Print an integer in binary format in Java
86. Converting Little Endian to Big Endian
87. StringBuilder vs String
88. How to read an unknown number of bytes from an inputStream (socket/socketServer)?
89. Receive byte[] using ByteArrayInputStream from a socket
90. How can I convert a 4-byte array to an integer?
91. Java ByteBuffer to String
92. How to convert a String into an ArrayList?
93. Default values to arguments in function
94. Static classes in Java
95. What is try-with-resources
96. Sort list of strings
97. Using enum
98. Collection.containsAll()
99. Add a list in a hashset using addAll
100. Convert list to a set
101. Comparing and removing elements not present in a List and array java
102. Convert List<String> to List<Integer> directly
103. Communication between java threads: stopping all threads when one finishes its task
104. Multithreading - Callable vs Runnable and Future
104b1. Multithreading - “implements Runnable” vs. “extends Thread”
104b2. Creating new Threads
104c. CountdownLatch
105. Difference between Arrays.asList(array) vs new ArrayList<Integer>(Arrays.asList(ia)) in java
106. Can I compile a java file with a different name than the class?
107. Is main method compulsory in Java
108. Java Data structures:
109. Difference between int[] array and int array[]
110. How to fill an array with certain value (zero fill)
110b. How can I initialize an ArrayList with all zeroes in Java?
111. How do I declare and initialize an array in Java?
112. Setting initial capacity to array list
113. Java Streams
114. Static nested class in Java, why
114b. Java inner class and static nested class
115. ExecutorService Shutdown
116. Catch multiple exceptions
117. Concatenate strings using System.out.println
118. Create array of certain size such that it can't grow beyond that
119. How can I pass a parameter to a Java Thread
120. Java Blocking Queue
121. Default Methods In Java
122. Interface with default methods vs Abstract class in Java 8
123. Java Scanner vs BufferedReader
124. Scanner method to get a char
125. Scanner is skipping nextLine() after using next(), nextInt() or other nextFoo()?
126. Read array using Scanner and BufferedReader
127. Read multiple lines from console
128. STRING OPERATIONS
128a. Find index of String in another string
128b. Get substring from String / StringBuilder
128c. Java indexOf method for multiple matches in String
129. How can I clear or empty a StringBuilder?
130. What is the best way to tell if a character is a letter or number in Java without using regexes?
131. How to determine if a String has non-alphanumeric characters
132. Don't assign one list to another
133. How to sort Map values by key in Java
134. Arrays.fill with multidimensional array in Java
135. Implement Comparator function
136. Possible Lossy conversion from long to int
137. How do I convert from int to Long in Java?
138. Do containsAll() and retainAll() in the Collection interface address cardinality?
139. Simple way to find if two different lists contain exactly the same elements?
140. CompareTo with primitives -> Integer / int
141. Initialization of an ArrayList in one line
142. How to convert int[] into List<Integer> in Java?
143. How to set a default value for items list / array?
144. Get Size of data types
145. Remove last character from String and StringBuilder
146. Convert int to int array
147. Change char in a StringBuilder
148. String equals
149. String.charAt() goes out of bound if index is beyond string length
--------------------------------------------------------------------------------------------

1.
Why Java uses Heap instead of Stack
http://stackoverflow.com/questions/15558245/why-does-java-use-heap-data-structure-to-store-object
http://stackoverflow.com/questions/3646632/do-java-primitives-go-on-the-stack-or-the-heap

    Primitives defined locally would be on the stack. However if a primitive were defined as part of an instance of an object, that primitive would be on the heap.
        public class Test
        {
            private static class HeapClass
            {
                public int y; // When an instance of HeapClass is allocated, this will be on the heap.
            }
            public static void main(String[] args)
            {
                int x=1; // This is on the stack.
            }
        }

    With regards to the update:
        Objects do not have their own stack.
        In my example, int y would actually be part of each instance of HeapClass.
        Whenever an instance of HeapClass is allocated (e.g. new HeapClass()), all member variables of HeapClass are added to the heap.
        Thus, since instances of HeapClass are being allocated on the heap, int y would be on the heap as part of an instance of HeapClass.

    However, all primitive variables declared in the body of any method would be on the stack.

    As you can see in the above example, int x is on the stack because it is declared in a method body--not as a member of a class.

2.
Access Specifiers
    a. Public:    Everyone
    b. Private:   Only that class
    c. Protected: Inheriting Class
    d. Default  : Class in the same package

3.
Early Binding
    In Java, late binding is the default behavior

4. 
Object Base Class
    All objects are inherited from Object Base Class

5.
What are Generics in Java
http://docs.oracle.com/javase/tutorial/java/generics/erasure.html
http://stackoverflow.com/questions/490091/java-generics

    - A type of container

    Type Erasure
    Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming.
    To implement generics, the Java compiler applies type erasure to:

        Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.
        Insert type casts if necessary to preserve type safety.
        Generate bridge methods to preserve polymorphism in extended generic types.

    Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.

    Vectors hold any old object you give them.
        V.add("This is an element");
        V.add(new Integer(2));
        v.add(new Hashtable());

    To get back the item
        String s = (String) v.get(0);
        Integer i = (Integer) v.get(1);
        Hashtable h = (Hashtable) v.get(2);
    
    Generics attempt to create strongly typed classes to do generic operations.
        ArrayList<String> aList = new ArrayList<String>();
        aList.add("One");
        String element = aList.get(0); // no cast needed
        System.out.println("Got one: " + element);

http://www.tutorialspoint.com/java/java_generics.htm
        public class GenericMethodTest
        {
           // generic method printArray                         
           public static < E > void printArray( E[] inputArray )
           {
              // Display array elements              
                 for ( E element : inputArray ){        
                    System.out.printf( "%s ", element );
                 }
                 System.out.println();
            }

            public static void main( String args[] )
            {
                // Create arrays of Integer, Double and Character
                Integer[] intArray = { 1, 2, 3, 4, 5 };
                Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
                Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

                System.out.println( "Array integerArray contains:" );
                printArray( intArray  ); // pass an Integer array

                System.out.println( "\nArray doubleArray contains:" );
                printArray( doubleArray ); // pass a Double array

                System.out.println( "\nArray characterArray contains:" );
                printArray( charArray ); // pass a Character array
            } 
        }

6. 
Heap and Stack Storage
    - Objects are stored on Heap
    - Primitive types are stored on Stack

7.
How Garbage Collector Works
http://stackoverflow.com/questions/774357/how-does-the-garbage-collection-mechanism-work

    - The way actual memory gets allocated to variables and the way it is reclaimed is abstracted from the programmer.
    - The acutal where the memory gets allocated is abstracted

    - When the GARBAGE COLLECTOR runs it will check if we still hold a reference to an object. If not it will free that memory.

    SIMPLEST:
        Reference counting:
            - Whenever an object gets referenced, a count is incremented
            - GARBAGE Collector moves through ALL THE OBJECTS and frees the ones that has ref count as ZERO
            PROBLEM:
            - Circular reference
			class Pointy {
				public Pointy other;
			}

			Pointy one = new Pointy();
			Pointy two = new Pointy();
			one.other = two;
			two.other = one;

    MARK and SWEEP
        The mark and sweep algorithm works by periodically stopping the execution of the program, mark each item the program has allocated as unreachable.
        The program then runs through all the variables the program has and marks what they point to as reachable.
        If either of these allocations contain references to other data in the program, that data is then likewise marked as reachable, etc.

        This is the mark part of the algorithm.
        At this point everything the program can access, no matter how indirectly, is marked as reachable and everything the program can't reach is marked as unreachable.
        The garbage collector can now safely reclaim the memory associated with the objects marked as unreachable.

        SWEEP: takes care of freeing all objexts that are not reachable

        PROBLEM:
            - Entire Program has to be stopped

    ADAPTIVE GARBAGE COLLECTION:
        - START @ RAM's static and stack portion and go through all the OBJECTS
        - Copy all live objects to ANOTHER HEAP. 
        - Remove the objects from original heap

        PROBLEM:
            - Twice the memory

        SOLUTION:
            - Once program is stable, don't have to KEEP copying as LITTLE or NO GARBAGE would be generated.
            - JVM detects this and switch to M&S

8.
How JVM works
https://www.youtube.com/watch?v=viS5d8DA_VI

    a1.c ---              a1.obj
            |
            |
    a2.c ---> COMPILER -- a2.obj ---> LINKER --> a.exe
            |
            |
    a3.c ---              a3.obj

    LOADER puts a.exe into Main Memory

    IN JAVA:
        - .class FILE CONTAINS the BYTECODE
        - NO LINKING IS DONE
        - JVM RESIDES on RAM

        a1.java                 a1.class

        a2.java ---> COMPILER ->a2.class

        a3.java                 a3.class

        - CLASS LOADER puts all the CLASS files ONTO RAM
        - BYTECODE Verifier verfies the Byte Code
            - Checks for ACCESS VIOLATION errors etc
        - EXECUTION ENGINE
            - USE JIT COMPILER and converts BYTE CODE into MACHINE CODE

9.
What is Escape Analysis:
http://programmers.stackexchange.com/questions/65281/stack-and-heap-memory-in-java
    - Escape analysis determines all the places where a pointer can be stored and whether the lifetime of the pointer can be proven to be restricted only to the current procedure and/or thread.
    - JVMs can use a technique called escape analysis, by which they can tell that certain objects remain confined to a single thread for their entire lifetime, and that lifetime is bounded by the lifetime of a given stack frame.
    - Such objects can be safely allocated on the stack instead of the heap.
    - Even better, for small objects, the JVM can optimize away the allocation entirely and simply hoist the object's fields into registers.
    
    Thus, if you have code that looks like:

        void foo(int arg) {
            Bar qux = new Bar(arg);
            ...
        }

    where the ... doesn't allow qux to leave that scope, qux may be allocated on the stack instead.
    This is actually a win for the VM because it means it doesn't need to ever be garbage collected - it will disappear when it leaves the scope

10.
Where objects are stored in Java
http://programmers.stackexchange.com/questions/65281/stack-and-heap-memory-in-java
http://stackoverflow.com/questions/3646632/do-java-primitives-go-on-the-stack-or-the-heap

    - Java only stores primitives on the stack.
    - Objects are created on the heap

    - Only REFERENCES (which in turn are primitives) are passed around on the stack.

    - An OBJECT with all its variables are PUT on HEAP

    class A {
       int a ;
       String b;
       //getters and setters
    }

    - Where will the primitive a in class A be stored?
        - Depends on Escape analysis and JVM

    - Why does heap memory exist at all? Why can't we store everything on the stack?
        - Then we would have to pass the full set of values from one function to another.
        - With heap only a reference to it is required.
        - You could have a huge string that occupies the entire stack memory

    - Why Stack memory exists ?
        - Compilers can have stuffs without a stack
        - Eg BASICS which just had 8 registers
        - STACK gets rid of MEMORY FRAGMENTATION
        - Advantage of SCOPE. On leaving the SCOPE the stack is popped.

    Primitives defined locally would be on the stack. However if a primitive were defined as part of an instance of an object, that primitive would be on the heap.

        public class Test
        {
            private static class HeapClass
            {
                public int y; // When an instance of HeapClass is allocated, this will be on the heap.
            }
            public static void main(String[] args)
            {
                int x=1; // This is on the stack.
            }
        }

    Objects do not have their own stack.
    In my example, int y would actually be part of each instance of HeapClass.
    Whenever an instance of HeapClass is allocated (e.g. new HeapClass()), all member variables of HeapClass are added to the heap.
    Thus, since instances of HeapClass are being allocated on the heap, int y would be on the heap as part of an instance of HeapClass.

    However, all primitive variables declared in the body of any method would be on the stack.

    As you can see in the above example, int x is on the stack because it is declared in a method body--not as a member of a class.

11.
Hashtable HashMap LinkedHashMap TreeMap
http://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/

    There are 4 commonly used implementations of Map in Java SE - HashMap, TreeMap, Hashtable and LinkedHashMap.
    If we use only one sentence to describe each implementation, it would be the following:

        HashMap is implemented as a hash table, and there is no ordering on keys or values.
        TreeMap is implemented based on red-black tree structure, and it is ordered by the key.
        LinkedHashMap preserves the insertion order
        Hashtable is synchronized, in contrast to HashMap. It has an overhead for synchronization.

        This is the reason that HashMap should be used if the program is thread-safe. 

11b.
LinkedHashMap Complexity and Usage

    If LinkedHashMap's time complexity is same as HashMap's complexity why do we need HashMap?

    You should not confuse complexity with performance. Two algorithms can have the same complexity, yet one can consistently perform better than the other.

    Remember that f(N) is O(N) means that:

    C1*N <= limit(f(N), N -> infinity) <= C2*N  

    where C1 and C2 are strictly positive constants. The complexity says nothing about how small or large the C values are. For two different algorithms, the constants will most likely be different.

    (And remember that big-O complexity is about the behavior / performance as N gets very large. It tells you nothing about the behavior / performance for small N values.)

12.
How to make System.out.println() shorter
http://stackoverflow.com/questions/3320764/how-to-make-system-out-println-shorter

    void println(Object line) {
        System.out.println(line);
    }

    println("Hello World");

13.
Using int vs Integer
http://stackoverflow.com/questions/564/what-is-the-difference-between-an-int-and-an-integer-in-java-and-c?rq=1

    If you can use int do so.
    If the value can be null or is used as an Object e.g. Generics, use Integer

    In Java an int is a primitive while an Integer is an Object. Meaning, if you made a new Integer:
        Integer i = new Integer(6);

    You could call some method on i:
        String s = i.toString();//sets s the string representation of i

    Whereas with an int:
        int i = 6;

    You cannot call any methods on it, because it is simply a primitive. So:
        String s = i.toString();//will not work!!!

    // IMP: Can't use "=="
        Integer alpha = new Integer(1);
        Integer foo = new Integer(1);

        if(alpha == foo) {
            System.out.println("1. true");
        }

        if(alpha.equals(foo)) {
            System.out.println("2. true");
        }

13b.
Using array vs ArrayList
http://stackoverflow.com/questions/2843928/benefits-of-arrays

    Arrays are better in the following situations:
        you know that you will work with fixed number of elements in the array
        you don't need to change size of the array
    Arrays are:
        faster than any Collection

    Arrays are more efficient, both in terms of processing time and memory footprint. This particularly applies if you are operating on primitive types, such as int or long, since List requires all elements to be wrapped in an Object (such as Integer or Long). While the autoboxing features introduced by Java 5 reduces the amount of code you need for such wrapping and unwrapping, it does not remove the performance issues, as wrapper objects are still being created.

    However, most applications probably do not have any performance bottlenecks related to these issues, so in most cases, List and other collections should do fine. In these cases, the ease of programming outweighs the increase in memory or CPU usage, and List is the right choice.

    One thing I have not seen mentioned here: arrays can have N dimensions whereas lists are limited to one. You can use lists of lists but the syntax (List<List<...>>) is much more cumbersome than [][]

    there is one subtle property of arrays that can be considered an advantage over lists. It can be illustrated by the following code:

    //This works
    Integer[] ints = new Integer[4];
    Number[] nums = ints;
    //This doesn't work
    List<Integer> intList = new ArrayList<Integer>();
    List<Number> numList = intList; //Does not compile
    List<Number> numList2 = (List<Number>)intList; //Does not compile either
    While an array of a subclass IS an array of the superclass, lists of subclasses are NOT lists of superclasses (and there is a good reason for it - generics would have a type safery flaw if it were allowed).

14.
How do I apply the for-each loop to every character in a String
http://stackoverflow.com/questions/2451650/how-do-i-apply-the-for-each-loop-to-every-character-in-a-string

    for (char ch: "xyz".toCharArray()) {
    }

    String s = "xyz";
    for(int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
    }

15.
Why can Java Collections not directly store Primitives types
http://stackoverflow.com/questions/2504959/why-can-java-collections-not-directly-store-primitives-types

    It was a Java design decision, and one that some consider a mistake.
    Containers want Objects and primitives don't derive from Object.

16.
Why is Java Vector class considered obsolete or deprecated
http://stackoverflow.com/questions/1386275/why-is-java-vector-class-considered-obsolete-or-deprecated

    Vector synchronizes on each individual operation.
    That's almost never what you want to do.

    Generally you want to synchronize a whole sequence of operations.
    Synchronizing individual operations is both less safe (if you iterate over a Vector, for instance, you still need to take out a lock to avoid anyone else changing the collection at the same time, which would cause a ConcurrentModificationException in the iterating thread) but also slower (why take out a lock repeatedly when once will be enough)?

    Of course, it also has the overhead of locking even when you don't need to.

    Basically, it's a very flawed approach to synchronization in most situations.

17.
What is meant by immutable
http://stackoverflow.com/questions/279507/what-is-meant-by-immutable

    Immutable means that once the constructor for an object has completed execution that instance can't be altered.

    This is useful as it means you can pass references to the object around, without worrying that someone else is going to change its contents.
    Especially when dealing with concurrency, there are no locking issues with objects that never change

    e.g.
    class Foo
    {
         private final String myvar;

         public Foo(final String initialValue)
         {
             this.myvar = initialValue;
         }

         public String getValue()
         {
             return this.myvar;
         }
    }

    Foo doesn't have to worry that the caller to getValue() might change the text in the string.

    If you imagine a similar class to Foo, but with a StringBuilder rather than a String as a member, you can see that a caller to getValue() would be able to alter the StringBuilder attribute of a Foo instance.

18.
Why is String immutable in Java
http://stackoverflow.com/questions/22397861/why-is-string-immutable-in-java
http://stackoverflow.com/questions/1552301/immutability-of-strings-in-java

    String is immutable for several reasons, here is a summary:

        Security: parameters are typically represented as String in network connections, database connection urls, usernames/passwords etc.
                  If it were mutable, these parameters could be easily changed.
        Synchronization and concurrency: making String immutable automatically makes them thread safe thereby solving the synchronization issues.
        Caching: When compiler optimizes your String objects, it sees that if two objects have same value (a="test", and b="test") and thus you need only one string object (for both a and b, these two will point to the same object).
        Class loading: String is used as arguments for class loading. If mutable, it could result in wrong class being loaded (because mutable objects change their state).

    That being said, immutability of String only means you cannot change it using its public API. You can in fact bypass the normal API using reflection. See the answer here.

    In your example, if String was mutable, then consider the following example:

      String a="stack";
      System.out.println(a);//prints stack
      a.setValue("overflow");
      System.out.println(a);//if mutable it would print overflow

19.
What does String Immutable mean
http://stackoverflow.com/questions/8798403/string-is-immutable-what-exactly-is-the-meaning

    Before proceeding further with the fuss of immutability, let's just take a look into the String class and its functionality a little before coming to conclusions about its immutability.

    This is how String works:
        String str = "knowledge";

    This, as usual, creates a string containing "knowledge" and assigns it a reference str.
    Simple enough? Lets perform some more functions:
         String s = str;     // assigns a new reference to the same string "knowledge"

    Lets see how the below statement works:
         str = str.concat(" base");

    This appends a string " base" to str. But wait, how is this possible, since String objects are immutable? Well to your surprise, it is.

    When the above statement is executed, the VM takes the value of String str, i.e. "knowledge" and appends " base", giving us the value "knowledge base".
    Now, since Strings are immutable, the VM can't assign this value to str, so it creates a new String object, gives it a value "knowledge base", and gives it a reference str.

    An important point to note here is that, while the String object is immutable, its reference variable is not.
    So that's why, in the above example, the reference was made to refer to a newly formed String object.

    At this point in the example above, we have two String objects: the first one we created with value "knowledge", pointed to by s, and the second one "knowledge base", pointed to by str.
    But, technically, we have three String objects, the third one being the literal "base" in the concat statement.

    IMPORTANT FACTS ABOUT STRING AND MEMORY USAGE:
        What if we didn't have another reference s to "knowledge"? We would have lost that String.
        However, it still would have existed, but would be considered lost due to having no references.
        Look at one more example below

            String s1 = "java";
            s1.concat(" rules");
            System.out.println("s1 refers to "+s1);  // Yes, s1 still refers to "java"

    What's happening:
        The first line is pretty straightforward: create a new String "java" and refer s1 to it.
        Next, the VM creates another new String "java rules", but nothing refers to it.
        So, the second String is instantly lost. We can't reach it.

    The reference variable s1 still refers to the original String "java".

    Almost every method, applied to a String object in order to modify it, creates new String object.
    So, where do these String objects go? Well, these exist in memory, and one of the key goals of any programming language is to make efficient use of memory.

    As applications grow, it's very common for String literals to occupy large area of memory, which can even cause redundancy.
    So, in order to make Java more efficient, the JVM sets aside a special area of memory called the "String constant pool".

    When the compiler sees a String literal, it looks for the String in the pool.
    If a match is found, the reference to the new literal is directed to the existing String and no new String object is created.
    The existing String simply has one more reference.
    Here comes the point of making String objects immutable:

    In the String constant pool, a String object is likely to have one or many references.
    If several references point to same String without even knowing it, it would be bad if one of the references modified that String value.
    That's why String objects are immutable.

    Well, now you could say, what if someone overrides the functionality of String class?
    That's the reason that the String class is marked final so that nobody can override the behavior of its methods.

20.
Combining charAt and IgnoreCasE
http://stackoverflow.com/questions/28387134/combining-charat-and-ignorecase

    (Character.toLowerCase(newGame.charAt(0)) == 'y');

21.
Adding Object to an ArrayList adds its reference
http://stackoverflow.com/questions/7080546/add-an-object-to-an-arraylist-and-modify-it-later
    
    Q. 
    If I have an ArrayList, and I added an object to it, and later I modified this object, will this change reflect in the ArrayList?
    Or when I add the object to the ArrayList, Java creates a copy and add it to the ArrayList?

    What if I change the reference to this object to null?
    Does that mean that the object in the ArrayList now null too?

    Q: will this change reflect in the ArrayList?
    A: Yes, since you added a reference to the object in the list. The reference you added will still point to the same object, (which you modified).

    Q: or when I add the object to the ArrayList, Java creates a copy and add it to the ArrayList?
    A: No, it won't copy the object. (It will copy the reference to the object.)

    Q: What if I change the reference to this object to null? Does that mean that the object in the ArrayList now null too?
    A: No, since the content of the original reference was copied when added to the list. (Keep in mind that it is the reference that is copied, not the object.)

        Demonstration:
        StringBuffer sb = new StringBuffer("foo");

        List<StringBuffer> list = new ArrayList<StringBuffer>();
        list.add(sb);

        System.out.println(list);   // prints [foo]
        sb.append("bar");

        System.out.println(list);   // prints [foobar]
        sb = null;

        System.out.println(list);   // still prints [foobar]

22.
Java Constructors and Super Class
http://stackoverflow.com/questions/3767365/super-in-java 

    1. If the FIRST LINE of the constructor is NOT a call to Super Class Constructor OR a call
    to ONE of its own constructor THEN the compiler will insert "super()" as the first line in
    the constructor

    2. Java WILL NOT insert a "super()" constructor if we already have one with arguments

    3. Always have a constructor with NO ARGUMENTS as java could add a "super()" and try to call
       a constructor with NO arguments.

    Calling exactly super() is always redundant.
    It's explicitly doing what would be implicitly done otherwise.
    That's because if you omit a call to the super constructor, the no-argument super constructor will be invoked automatically anyway.
    Not to say that it's bad style; some people like being explicit.

    However, where it becomes useful is when the super constructor takes arguments that you want to pass in from the subclass.

        public class Animal {
           private final String noise;
           protected Animal(String noise) {
              this.noise = noise;
           }

           public void makeNoise() {
              System.out.println(noise);
           }
        }

        public class Pig extends Animal {
            public Pig() {
               super("Oink");
            }
        }

23.
Exceptions
    - If a client can reasonably be expected to recover from an exception, make it a checked exception.
    - If a client cannot do anything to recover from the exception, make it an unchecked exception

    Checked Exception vs Unchecked Exception:
        - Checked Exception should be DECLARED in the method

        - Common exception such as NULL pointer exceptions are Unchecked exceptions

    UNCHECKED:
        - Unchecked are the exceptions that are not checked at compiled time.
        - In C++, all exceptions are unchecked, so it is not forced by the compiler to either handle or specify the exception.

24.
Final, Finally, Finalize
http://stackoverflow.com/questions/7814688/in-java-what-purpose-do-the-keywords-final-finally-and-finalize-fulfil

    1. final
        - final can be used to mark a variable "unchangeable"
            private final String name = "foo";  //the reference name can never change

        - final can also make a method not "overrideable"
            public final String toString() {  return "NULL"; }

        - final can also make a class not "inheritable". i.e. the class can not be subclassed
            public final class finalClass {...}
            public class classNotAllowed extends finalClass {...} // Not allowed

    2. finally
        - finally is used in a try/catch statement to execute code "always"
            lock.lock();
            try {
              //do stuff
            } catch (SomeException se) {
              //handle se
            } finally {
              lock.unlock(); //always executed, even if Exception or Error or se
            }

        Java 7 has a new try with resources statement that you can use to automatically close resources that explicitly or implicitly implement java.io.Closeable or java.lang.AutoCloseable

    3. finalize
        finalize is called when an object is garbage collected. You rarely need to override it.
        An example:
            protected void finalize() {
              //free resources (e.g. unallocate memory)
              super.finalize();
            }

24b.
Final in Java
http://stackoverflow.com/questions/15655012/how-final-keyword-works
Thinking in Java
    
    Why Final?
        - To create a constant
        1. Compile Time Constant:
            - Value Won't ever change
            - Calculations using compile time constants can be performed at compile time
            - This eliminates runtime overhead

            - Use "final" on primitive data types to create compile time constants
            - Also a value MUST be given at compile time

            IMP: 
              final int a;
              Error will be thrown only when trying to access the variable

        2. Run time constant:
            - Value gets initialized at run time

            - Using "final" on Object References makes the REFERENCE a constant
            - Once the reference is initialized to an object, it can never be changed to
              point to another object.
            - But the object itself can be modified

25.
How to find index of min element in a list
http://stackoverflow.com/questions/15995458/how-to-find-the-minimum-value-in-an-arraylist-along-with-the-index-number-jav

    int minIndex = list.indexOf(Collections.min(list));

26.
Get current date and time
http://stackoverflow.com/questions/833768/java-code-for-getting-current-time

    new java.util.Date() : Human Readable Format
    System.currentTimeMillis() : 1478422910095

27.
Priority Queue peek, element, poll, remove
http://www.davismol.net/2014/04/04/java-ocpjp7-difference-between-element-peek-poll-and-remove-methods-of-the-queue-interface/

    The peek() method retrieves the value of the first element of the queue without removing it from the queue.
    For each invocation of the method we always get the same value and its execution does not affect the size of the queue. If the queue is empty the peek() method returns null.

    The element() method behaves like peek(), so it again retrieves the value of the first element without removing it. Unlike peek ), however, if the list is empty element() throws a NoSuchElementException

    The poll() method retrieves the value of the first element of the queue by removing it from the queue.
    At each invocation it removes the first element of the list and if the list is already empty it returns null but does not throw any exception

    The remove() method behaves as the poll() method, so it removes the first element of the list and if the list is empty it throws a NoSuchElementException

28.
Priority Queue Offer vs Add
http://stackoverflow.com/questions/2703984/what-is-the-difference-between-the-add-and-offer-methods-in-a-queue-in-java

    The Queue interface specifies that add() will throw an IllegalStateException if no space is currently available (and otherwise return true) while offer() will return false if the element couldn't be inserted due to capacity restrictions.

28b. Priority Queue Reverse Order:
https://stackoverflow.com/questions/11003155/change-priorityqueue-to-max-priorityqueue

    Java 8:
    PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());

    PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);

	PriorityQueue<Integer> pq = new PriorityQueue<Integer>(defaultSize, new Comparator<Integer>() {
    int compare(Integer lhs, Integer rhs) {
        if (lhs > rhs) return +1;
        if (lhs.equals(rhs)) return 0;
        return -1;
    }
});

29.
for each loop in Java

    for (int intValue : test) {
        // do some work here on intValue
    }

30.
Increment Value of a HashMap's Key
http://stackoverflow.com/questions/4157972/how-to-update-a-value-given-a-key-in-a-java-hashmap

    - map.put(key, map.get(key) + 1);
    - Replace Integer by AtomicInteger and call one of the incrementAndGet/getAndIncrement methods on it.
    - An alternative is to wrap an int in your own MutableInteger class which has an increment()

30b.
Print All Key Valye pairs of Hashmap in Java

    map.put("A", 1);
    map.put("B", 2);
    map.put("C", 3);

    for (String key : map.keySet()) {
        System.out.println(key + " " + map.get(key));
    }

    for (Map.Entry<KeyType, ValueType> entry : map.entrySet()) {
        System.out.println(entry.getKey()+" : "+entry.getValue());
    }

30c. Add to an arraylist in HashMap
https://stackoverflow.com/questions/12134687/how-to-add-element-into-arraylist-in-hashmap


31.
How to split a string in Java
http://stackoverflow.com/questions/3481828/how-to-split-a-string-in-java

        String string = "004-034556";
        String[] parts = string.split("-");
        String part1 = parts[0]; // 004
        String part2 = parts[1]; // 034556

    Note that this takes a regular expression, so remember to escape special characters if necessary.
    There are 12 characters with special meanings: the backslash \, the caret ^, the dollar sign $, the period or dot ., the vertical bar or pipe symbol |, the question mark ?, the asterisk or star *, the plus sign +, the opening parenthesis (, the closing parenthesis ), and the opening square bracket [, the opening curly brace {, These special characters are often called "metacharacters".

    So, if you want to split on e.g. period/dot . which means "any character" in regex, use either backslash \ to escape the individual special character like so split("\\."), or use character class [] to represent literal character(s) like so split("[.]"), or use Pattern#quote() to escape the entire string like so split(Pattern.quote(".")).

        String[] parts = string.split(Pattern.quote(".")); // Split on period.

    ",\\s*" - comma followed by any whitespace

    https://books.google.com/books?id=diqHjRjMhW0C&pg=PA24&lpg=PA24&dq=java+string+split+%22,%5C%5Cs*%22&source=bl&ots=IwpwyEfgmz&sig=n0PZCuhVxDx5pwgEZI1D_YpTXrE&hl=en&sa=X&ved=0ahUKEwi5g76FuOHRAhVO3WMKHVd7C_UQ6AEISTAI#v=onepage&q=java%20string%20split%20%22%2C%5C%5Cs*%22&f=false
    \s - Whitespace (space, tab, line feed, carriage return)
    \S - Non Whitespace
    \d - Digits
    \D - Non Digits
    \w - 0-9,a-z,A-Z,_
    \W - Non word chars
    *  - Repeat preceding pattern 0 or more times
    +  - Repeat preceding pattern 1 or more times
    ?  - Repeat preceding pattern 0 or 1 times
32. 
Java String to Int and Int to String
http://stackoverflow.com/questions/5585779/converting-string-to-int-in-java
http://stackoverflow.com/questions/3335737/integer-tostringint-i-vs-string-valueofint-i

		String s = "1234";
		int i = Integer.parseInt(s);
		System.out.println(i);
		
		i++;
		String t = String.valueOf(i);
		System.out.println(t);

32b. Difference between parseInt and valueOf in java?
    Well, the API for Integer.valueOf(String) does indeed say that the String is interpreted exactly as if it were given to Integer.parseInt(String). However, valueOf(String) returns a new Integer() object whereas parseInt(String) returns a primitive int

    If you want to enjoy the potential caching benefits of Integer.valueOf(int), you could also use this eyesore:
        Integer k = Integer.valueOf(Integer.parseInt("123"))

    Now, if what you want is the object and not the primitive, then using valueOf(String) may be more attractive than making a new object out of parseInt(String) because the former is consistently present across Integer, Long, Double, etc

33.
Iterating over a Map using EntrySet
http://stackoverflow.com/questions/5428897/why-do-we-use-entryset-method-and-use-the-retured-set-to-iterate-a-map

    This is as close to iterating over the map as we can because you have to say whether you want just the keys, just the values or the whole key/value entry.
    For Sets and Lists, there is only one option so, no need to have a separate method to do this.

    BTW: This is how I would iterate over a Map.

        Map<K,V> m=new LinkedHashMap<K,V>();
        for(Map.Entry<K,V> entry: m.entrySet())
            System.out.println(entry.getKey() + ": " + entry.getValue());

    In Java 8 you can write
        m.forEach((k, v) -> System.out.println(k + ": " + v));

34.
Signed Right Shift and Unsigned Right Shift
http://www.geeksforgeeks.org/bitwise-shift-operators-in-java/

    >> (Signed right shift)
        In Java, the operator >> is signed right shift operator.
        All integers are signed in Java, and it is fine to use >> for negative numbers.
        The operator >> uses the sign bit (left most bit) to fill the trailing positions after shift.
        If the number is negative, then 1 is used as a filler and if the number is positive, then 0 is used as a filler.

    >>> (Unsigned right shift)
        In Java, the operator >>> is unsigned right shift operator.
        It always fills 0 irrespective of the sign of the number.

35.
Method Variables and Class Variables

    Class Variables:
        - All Class variables must be initialized if the variable is FINAL
        - If NO final, then the class variables gets the DEFAULT VALUE

    Method Variables:
        - Method variables MUST be initialized before being used

36.
Creating Java Objects

    The only way to create a new object in Java is with new [1].
    However, in some classes, you're not permitted to say new for yourself, you must call a factory method, which might be static (as with your logger example) or not.

37.
Why Java string does not need new to create

    String literals [ie, Strings like "abcd" but not like new String("abcd")] in Java are interned - this means that every time you refer to "abcd", you get a reference to a single String instance, rather than a new one each time.

    So you will have
        String a = "abcd";
        String b = "abcd";

        a == b; //True

    but if you had
        String a = new String("abcd")
        String b = new String("abcd")

    then its possible to have
        a == b; // False

    (and in case anyone needs reminding, always use .equals() to compare Strings; == tests for physical equality)

    Interning String literals is good because they are often used more than once. For example, consider the (contrived) code:

        for (int i = 0; i < 10; i++) {
          System.out.println("Next iteration");
        }

    If we didn't have interning of Strings, "Next iteration" would need to be instantiated 10 times, whereas now it will only be instantiated once.

38.
How are Java objects stored in memory

    When we only declare a variable of a class type, only a reference is created (memory is not allocated for the object).
    To allocate memory to an object, we must use new(). So the object is always allocated memory on heap

38b.
When is memory allocated
http://stackoverflow.com/questions/25055375/when-is-memory-allocated-during-instance-creating-or-using-new-keyword-for-objec

    Variables declared within a method are stored within the stack, while the actual objects are stored on the heap. Consider

        Integer a = new Integer(10);

    In this example, an object of type Integer is created on the heap and a reference (either 32 or 64bits) is returned and stored within the methods stack as variable 'a'.
    The JVM is free to keep variables like this within the CPU registers if it prefers as an optimization.

    Memory of an object is allocated when the new keyword is used.

39.
Java Pass by value or Pass by reference
http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value

    The key to understanding this is that something like

        Dog myDog;

    is not a Dog; it's actually a pointer to a Dog.

    What that means, is when you have you're essentially passing the address of the created Dog object to the foo method.

        Dog myDog = new Dog("Rover");
        foo(myDog);

    (I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)

    Suppose the Dog object resides at memory address 42. This means we pass 42 to the method.

    if the Method were defined as

        public void foo(Dog someDog) {
            someDog.setName("Max");     // AAA
            someDog = new Dog("Fifi");  // BBB
            someDog.setName("Rowlf");   // CCC
        }

    let's look at what's happening.

        the parameter someDog is set to the value 42
        at line "AAA"
            someDog is followed to the Dog it points to (the Dog object at address 42)
            that Dog (the one at address 42) is asked to change his name to Max
        at line "BBB"
            a new Dog is created. Let's say he's at address 74
            we assign the parameter someDog to 74
        at line "CCC"
            someDog is followed to the Dog it points to (the Dog object at address 74)
            that Dog (the one at address 74) is asked to change his name to Rowlf
        then, we return

    Now let's think about what happens outside the method:

    Did myDog change?

    There's the key.

    Keeping in mind that myDog is a pointer, and not an actual Dog, the answer is NO.
    myDog still has the value 42; it's still pointing to the original Dog (but note that because of line "AAA", its name is now "Max" - still the same Dog; myDog's value has not changed.)

    --------
    Java is always pass-by-value.
    Unfortunately, they decided to call pointers references, thus confusing newbies.
    Because those references are passed by value.

    It goes like this:
        public static void main( String[] args ){
            Dog aDog = new Dog("Max");
            foo(aDog);

            if (aDog.getName().equals("Max")) { //true
                System.out.println( "Java passes by value." );

            } else if (aDog.getName().equals("Fifi")) {
                System.out.println( "Java passes by reference." );
            }
        }

        public static void foo(Dog d) {
            d.getName().equals("Max"); // true

            d = new Dog("Fifi");
            d.getName().equals("Fifi"); // true
        }

    In this example aDog.getName() will still return "Max".
    The value aDog within main is not overwritten in the function foo with the Dog "Fifi" as the object reference is passed by value.
    If it were passed by reference, then the aDog.getName() in main would return "Fifi" after the call to foo.

    Likewise:
        Dog aDog = new Dog("Max");
        foo(aDog);
        aDog.getName().equals("Fifi"); // true
        public void foo(Dog d) {
            d.getName().equals("Max"); // true
            d.setName("Fifi");
        }

    In the above example, FiFi is the dog's name after call to foo(aDog).
    Any operations that foo performs on d are such that, for all practical purposes, they are performed on aDog itself (except d=new Dog("Boxer")).

40.
Check ArrayLists is empty

    isEmpty() to check if arrayList is empty.

41.
Check if Array is empty
    
    int[] arr = null;
    if (arr == null || arr.length == 0)

	int[] a = new int[5]; // Array is NOT EMPTY AND NOT NULL
	if (a == null) {
		System.out.println("NULL"); // Won't print
	}
	if (a.length == 0) {
		System.out.println("Empty"); // Won't print
	}
	System.out.println("Done"); // Gets printed

42.
Convert Array to ArrayList

    new ArrayList<Element>(Arrays.asList(array))

42a. How to convert int[] into List<Integer> in Java?
    There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> which is not what you want. 

    List<Integer> Ints.asList(int...)
    
    int[] ints = {1,2,3};
    List<Integer> list = Arrays.stream(ints).boxed().collect(Collectors.toList());


42b.
Convert ArrayList to Array in Java

    String[] dsf = new String[al.size()];
    al.toArray(dsf);

    String names[]=list.toArray(new String[list.size()])

42c. 
How to convert List<Integer> to int[] in Java?
https://stackoverflow.com/questions/960431/how-to-convert-listinteger-to-int-in-java

    1. Unfortunately, I don't believe there really is a better way of doing this due to the nature of Java's handling of primitive types, boxing, arrays and generics. In particular:

    List<T>.toArray won't work because there's no conversion from Integer to int

    2. Using strams:
        int[] array = list.stream().mapToInt(i->i).toArray();

    3. 
    In addition to Commons Lang, you can do this with Guava's method Ints.toArray(Collection<Integer> collection):

        List<Integer> list = ...
        int[] ints = Ints.toArray(list);

    4. 
        int[] toIntArray(List<Integer> list)  {
            int[] ret = new int[list.size()];
            int i = 0;
            for (Integer e : list)  
                ret[i++] = e.intValue();
            return ret;
        }

43.
Integer MAX_VALUE
    
    int i = Integer.MAX_VALUE;

44.
Char array to String

    char[] a = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};
    String b = new String(a);

45.
String to Char Array

    String.toCharArray();

46.
Length Length() and Size()

    length --- arrays (int[], double[], String[]) ---- to know the length of the arrays
    length() --- String related Object (String, StringBuilder etc)to know the length of the String
    size() --- Collection Object (ArrayList, Set etc)to know the size of the Collection 

47.
How to use Iterator in Java

        List<String> list = new ArrayList<String>();

		System.out.println("#4 iterator");
		Iterator<String> iterator = list.iterator();

		while (iterator.hasNext())
        {
			System.out.println(iterator.next());
		}

48.
Generating Random Number
http://stackoverflow.com/questions/363681/generating-random-integers-in-a-specific-range 
http://stackoverflow.com/questions/5887709/getting-random-numbers-in-java

    0. Generating Random Number between 1 and N
        a. Math.random
            random() method returns a random number between 0.0 and 0.999

            double random = Math.random() * 50 + 1;
            or
            int random = (int )(Math.random() * 50 + 1);

        b.
            Random rand = new Random(); 
            int value = rand.nextInt(50);

            This will give value from 0 to 49.
            For 1 to 50: rand.nextInt((max - min) + 1) + min;

    1. Generating Random Number in a Range between Min and Max
        a.
            Min + (int)(Math.random() * ((Max - Min) + 1))
            This returns a value in the range [0,Max-Min), where 'Max-Min' is not included.

        b.
            import java.util.concurrent.ThreadLocalRandom;

            // nextInt is normally exclusive of the top value,
            // so add 1 to make it inclusive
            ThreadLocalRandom.current().nextInt(min, max + 1);

49.
Using Synchronized in Java
http://tutorials.jenkov.com/java-concurrency/synchronized.html

 The synchronized keyword can be used to mark four different types of blocks:

    1. Instance methods
          public synchronized void add(int value){
          this.count += value;
      }

    2. Static methods
          public static synchronized void add(int value){
              count += value;
          }
    3. Code blocks inside instance methods
          public void add(int value){

            synchronized(this){
               this.count += value;   
            }
          }
    4. Code blocks inside static methods
        public static void log2(String msg1, String msg2){
           synchronized(MyClass.class){
              log.writeln(msg1);
              log.writeln(msg2);  
           }
        }

50.
Converting int to Integer and Integer to int
http://stackoverflow.com/questions/4052085/passing-integer-to-int-and-vice-versa

    This is auto-boxing and auto-unboxing.
    Basically the compiler puts in calls to Integer.valueOf() or x.intValue() appropriately

51.
Iterator for LinkedHashMap
http://stackoverflow.com/questions/13735574/how-do-i-iterate-through-a-java-linked-hash-map

    Map<String, User> users = new LinkedHashMap<String, User>();
    users.put(name, user);

    for (Map.Entry<String,User> entry : users.entrySet()) {
        // entry.getValue() is of type User now
    }

    Iterator<User> it = users.values().iterator();
    while (it.hasNext())
    {
      User currentUser = it.next();
      currentUser.someMethod();
    }

52.
What are Packages

    - Packaging breaks down projects into meaningful segments
    - I a large application, you are bound to have two files named exactly the same (java.util.Date and java.sql.Date), especially when you start bringing in third party jars.
    - Ensure uniqueness.
    - A Java package is a mechanism for organizing Java classes into namespaces similar to the modules of Modula.
    - Java packages can be stored in compressed files called JAR files, allowing classes to download faster as a group rather than one at a time.
    - Programmers also typically use packages to organize classes belonging to the same category or providing similar functionality.

    - Preventing naming conflicts.
    - Making searching/locating and usage of classes, interfaces, enumerations and annotations easier
    - Providing controlled access: protected and default have package level access control
    - Packages can be considered as data encapsulation (or data-hiding).

53.
What is CLASSPATH

    - Think of it as Java's answer to the PATH environment variable
    - OSes search for EXEs on the PATH.
    - Java searches for classes and packages on the classpath

    When programming in Java, you make other classes available to the class you are writing by putting something like this at the top of your source file:
        import org.javaguy.coolframework.MyClass;

    Or sometimes you 'bulk import' stuff by saying:
        import org.javaguy.coolframework.*;

    So later in your program when you say:
        MyClass mine = new MyClass();

    The Java Virtual Machine will know where to find your compiled class.

    It would be impractical to have the VM look through every folder on your machine, so you have to provide the VM a list of places to look.
    This is done by putting folder and jar files on your classpath

54.
What is Strongly Typed / Weak Typed, Static Typed and Dynamic Typed Language
http://stackoverflow.com/questions/2351190/static-dynamic-vs-strong-weak
    - Java is statically typed and also a strongly typed language

    - Don't use the terms "strong" and "weak" typing, because they don't have a universally agreed on technical meaning

    - Static/Dynamic typing is about when type information is aquired (Either at compiletime or at runtime)

    - Strong/Weak typing is about how strictly types are distinguished (e.g. whether the language tries to do implicit conversion from strings to numbers)

55.
C++ Features Missing in Java

    No pointers
    No sizeof operator
    No scope resolution operator
    Local variables in functions cannot be static
    No Multiple Inheritance
    No Operator Overloading
    No preprocessor and macros
    No user suggested inline functions
    No goto
    No default arguments
    No unsigned int in Java
    No -> operator in java
    No stack allocated objects in java
    No delete operator in java due to javas garbage collection
    No destructor in java
    No typedef in java
    No global variables, no global function because java is pure OO.
    No friend functions
    No friend classes
    No templates in java

56.
Java Main Class need not be Public
http://www.geeksforgeeks.org/myth-file-name-class-name-java/

    - It is just that the standard enforces using Public class 

    If Main class is not Public, following error gets generated
        javac Trial.java
        Trial.java:9: error: class Geeks is public, should be
                            declared in a file named Geeks.java
        public class Geeks

    But the myth can be violated in such a way to compile the above file.
        /***** File name: Trial.java ******/
        class Geeks
        {
            public static void main(String[] args) {
                System.out.println("Hello world");
            }
        }

    Step 1: javac Trial.java
        Step1 will create a Geeks.class (byte code) without any error message since the class is not public.

    Step 2: java Geeks
        Now the output will be Hello world

    /*** File name: Trial.java ***/
    class ForGeeks
    {
       public static void main(String[] args){
          System.out.println("For Geeks class");
       }
    }
     
    class GeeksTest
    {
       public static void main(String[] args){
          System.out.println("Geeks Test class");
       }
    }

    When the above file is compiled as javac Trial.java will create two .class files as ForGeeks.class and GeeksTest.class .
    Since each class has separate main() stub they can be tested individually.
    When java ForGeeks is executed the output is For Geeks class.
    When java GeeksTest is executed the output is Geeks Test class.

57.
What is Volatile in Java

     "volatile" tells the compiler that the value of a variable must never be cached as its value may change outside of the scope of the program itself.

    The values of volatile variable will never be cached and all writes and reads will be done to and from the main memory.
    However, use of volatile is limited to very restricted set of cases as most of the times atomicity is desired

58.
Can't use INT as Bool in condition
http://stackoverflow.com/questions/13806021/checking-the-boolean-result-of-an-int-type

    int i = 5;
    if (i) <-- Fails

    int y = (int)(i == 5); <--- Fails too

59.
>>> and >>
    >> is arithmetic shift right, >>> is logical shift right.

    In an arithmetic shift, the sign bit is extended to preserve the signedness of the number.

60.
try catch throw throws finally

    - Checked Exception
        - These are compile time exceptions
    - Unchecked Excpetion:
        - These are Runtime exception
    - Try must have a catch or finally
    - throw to throw custom exception
    - Throwable is a super class for all types of errors and exceptions in java.

    - "Throws keyword" is mainly used for handling checked exception as using throws we can declare multiple exceptions in one go.
    1. The throws keyword is used in method declaration, in order to explicitly specify the exceptions that a particular method might throw.
    When a method declaration has one or more exceptions defined using throws clause then the method-call must handle all the defined exceptions.

    2. When defining a method you must include a throws clause to declare those exceptions that might be thrown but doesnt get caught in the method.

    3. If a method is using throws clause along with few exceptions then this implicitly tells other methods that   If you call me, you must handle these exceptions that I throw.

        class MyOwnException extends Exception {
           public MyOwnException(String msg){
              super(msg);
           }
        }

        class EmployeeTest {
           static void  employeeAge(int age) throws MyOwnException{
              if(age < 0)
                 throw new MyOwnException("Age can't be less than zero");
              else
                 System.out.println("Input is valid!!");
           }
           public static void main(String[] args) {
               try {
                    employeeAge(-2);
               }
               catch (MyOwnException e) {
                    e.printStackTrace();
               }
           }
        }

61.
What is finalize

    finalize is present in every Object
    - If we want to do some type of cleanup before the object gets cleaned by the garbage
      collector, we can add those inside finalize method in the Class

62.
Create 2D Array in Java

    1.
    int[][] multi = new int[5][10];

    2.
    int[][] multi = new int[5][];
    multi[0] = new int[10];
    multi[1] = new int[10];
    multi[2] = new int[10];
    multi[3] = new int[10];
    multi[4] = new int[10];

    3.
    int marks[][]={{50,60,55,67,70},{62,65,70,70,81},{72,66,77,80,69}};

63.
Access Specifiers in Java

    Classes and Interfaces can have only two access specifiers when declared outside any other class.
    1) public
    2) default (when no access specifier is specified)

    Methods and Members:
    Access Levels
    Modifier 	Class 	Package 	Subclass 	World
    public 	    Y 	    Y 	        Y 	        Y
    protected 	Y 	    Y 	        Y 	        N
    no modifier	Y 	    Y 	        N 	        N
    private 	Y 	    N 	        N 	        N

64.
Find log base 2 of a number

    logb(n) = log(n) / log(b)

65.
Convert a char to an int or Get numeric value of a character

        char c= '5';
        Character.getNumericValue(c)

66.
What is THIS
    Anit:
    When an object is created a invisible "this" gets created.
    When we call a method through the object, "this" gets passed

67.
Java Heap Old gen, Perm Gen and Young gen
http://stackoverflow.com/questions/2129044/java-heap-terminology-young-old-and-permanent-generations

http://stackoverflow.com/questions/3849634/static-allocation-in-java-heap-stack-and-permanent-generation/3849819#3849819

https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html

68.
Declare array in Java

        int[] myIntArray = new int[3];
        int[] myIntArray = {1,2,3};
        int[] myIntArray = new int[]{1,2,3};

    For classes, for example String, it's the same:
        String[] myStringArray = new String[3];
        String[] myStringArray = {"a","b","c"};
        String[] myStringArray = new String[]{"a","b","c"};

69.
Boolean[] vs BitSet
http://stackoverflow.com/questions/605226/boolean-vs-bitset-which-is-more-efficient

    From some benchmarks with Sun JDK 1.6 computing primes with a sieve (best of 10 iterations to warm up, give the JIT compiler a chance, and exclude random scheduling delays, Core 2 Duo T5600 1.83GHz):

    BitSet is more memory efficient than boolean[] except for very small sizes.
    Each boolean in the array takes a byte.
    The numbers from runtime.freeMemory() are a bit muddled for BitSet, but less.

    boolean[] is more CPU efficient except for very large sizes, where they are about even.
    E.g., for size 1 million boolean[] is about four times faster (e.g. 6ms vs 27ms), for ten and a hundred million they are about even.

70.
ArrayList get set

        int t = arr.get(0);
        arr.set(0, arr.get(1));
        arr.set(1, t);

71.
Array and ArrayList pass reference by value

    So value gets changed in caller

        {
	    int[] c = new int[2];
	    c[0] = 5;
	    c[1] = 3;
	    System.out.println(c[0]);
	    System.out.println(c[1]);
	    System.out.println();
	    
	    mySwap(c);
	    System.out.println(c[0]);
	    System.out.println(c[1]);
	    
	    ArrayList<Integer> al = new ArrayList<>();
	    al.add(5);
	    al.add(3);
	    System.out.println(al);
	    
	    mySwap2(al);
	    System.out.println(al);
        }

        static void mySwap(int[] arr)
        {
            int t = arr[0];
            arr[0] = arr[1];
            arr[1] = t;
        }
        
        static void mySwap2(ArrayList<Integer> arr)
        {
            int t = arr.get(0);
            arr.set(0, arr.get(1));
            arr.set(1, t);
        }

72.
Change a character in a String

    String are immutable in Java. You can't change them.
    You need to create a new string with the character replaced.

        String myName = "domanokz";
        String newName = myName.substring(0,4)+'x'+myName.substring(5);

    Or you can use a StringBuilder:
        StringBuilder myName = new StringBuilder("domanokz");
        myName.setCharAt(4, 'x');

        System.out.println(myName);

73.
Java FileChannel - Java NIO
https://examples.javacodegeeks.com/core-java/nio/filechannel/java-nio-channels-filechannel-example/

    - NIO - New IO
    - NIO allows Java programmers to implement high-speed I/O without having to write custom native code.
    - NIO moves the most time consuming I/O activities (like, filling and draining buffers) back into the operating system, thus providing increase in speed.
    - NIO makes I/O faster than traditional I/O.

    - File channels are read/write channels and they are always blocking.
    - This is a channel for reading, writing, mapping, and manipulating a file. FileChannel objects are thread-safe.

74.
    @Override
    It's a hint for the compiler to let it know that you're overriding the method of a parent class (or interface in Java 6).

    If the compiler detects that there IS no function to override, it will warn you (or error).

    This is extremely useful to quickly identify typos or API changes.
    Say you're trying to override your parent class' method harvest() but spell it harvset(), your program will silently call the base class, and without @Override, you wouldn't have any warning about that.

75.
Get Boolean from a String
    Boolean boolean1 = Boolean.valueOf("true");
    boolean boolean2 = Boolean.parseBoolean("true");
    Advantage:

    Boolean: this does not create new instances of Boolean, so performance is better (and less garbage-collection). It reuses the two instances of either Boolean.TRUE or Boolean.FALSE.
    boolean: no instance is needed, you use the primitive type.

76.
Try Catch Throws - Komprise
    - You don't have to catch a Local Exception and another another string or message to it.
    - You just throw it as such

    - Add all your exceptions to local exception
    - Finally before throwing the local exception, log and throw it

77.
String concatenation for Logging {} vs +
http://stackoverflow.com/questions/2245088/how-to-display-stack-trace-on-a-caught-exception
https://stackoverflow.com/questions/8755063/concatenation-operator-vs-concat

    The concat method always produces a new String with the result of concatenation.

    The plus operator is backed by StringBuilder creation, appending all String values you need and further toString() calling on it.

    So, if you need to concatenate two values, concat() will be better choice. If you need to concatenate 100 values, you should use the plus operator or explicitly use StringBuilder (e.g. in case of appending in a cycle).

	--------
	In fact s1 + s2 and s1.concat(s2) are very different.

	s1 + s2 is converted by javac into

	(new StringBuilder(String.valueOf(s1)).append(s2).toString();
	You can see it if you decompile .class. This construct is not very efficient; it involves up to three new char[] allocations and three char[] copy operations.

	s1.concat(s2) is always one new char[] + one copy operation, see String.java

	public String concat(String str) {
		int otherLen = str.length();
		if (otherLen == 0) {
			return this;
		}
		char buf[] = new char[count + otherLen];
		getChars(0, count, buf, 0);
		str.getChars(0, otherLen, buf, count);
		return new String(0, count + otherLen, buf);
	}
	Note that new String(int, int, char[]) is String's package private constructor. It uses char buf[] directly, without the usual copying to ensure the buf invisibility for the String immutability.
	--------
	I believe the 'style' of concatenation is going to make a difference.

	For concat(), it internally creates a new char array buffer, and returns a new string based on that char array.

	For the + operator, the compiler in fact translate it to use StringBuffer/StringBuilder.

	Therefore, if you are concatenating two strings, concat() is definitely a better choice because the number of objects created is only the result String (and the char buffer used inside), while using the  + operator will be translated to:

	result = strA + strB;
	-- translate to -->
	result = new StringBuilder(strA).append(strB).toString();
	An extra StringBuilder instance is created.

	However, if you are concatenating, for example five strings in a row, each concat() will create a new String object. While using the + operator, the compiler will translate the statement to one StringBuilder with multiple append operations. It is definitely saving a lot of unnecessary temporary object instance:

	result = strA + strB + strC + strD + strE;
	-- translate to -->
	result = new StringBuilder(strA).append(strB).append(strC).append(strD).append(strE).toString();

78.
Logging exception
http://stackoverflow.com/questions/10555409/logger-slf4j-advantages-of-formatting-with-instead-of-string-concatenation

79.
How to fix Could not find or load main class error
    Run using java -cp . 

80.
Run class inside a jar, MVN Building app into JAR with all dependencies and running the app - Fat JAR
    Change pom.xml to include the following

    Converting Java Program to Jar:
    http://stackoverflow.com/questions/2887473/how-to-convert-java-program-into-jar

    Add a MANIFEST.MF file:
        Manifest-Version: 1.2
        Main-Class: your.package.Main

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>fully.qualified.MainClass</mainClass>
                        </manifest>
                    </archive>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                </configuration>
            </plugin>

            <plugin>
                <!-- Build an executable JAR -->
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.0.2</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <classpathPrefix>lib/</classpathPrefix>
                            <mainClass>prag.jacksonXml.App</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>

	Compile using mvn:
	http://stackoverflow.com/questions/574594/how-can-i-create-an-executable-jar-with-dependencies-using-maven
		mvn clean compile assembly:single

    Run the jar using
    Run java from Jar, Run class inside a jar
        java -cp jacksonXml-1.0-SNAPSHOT-jar-with-dependencies.jar prag.jacksonXml.App

81.
How to resolve Could not find or load main class Foo error
    java -cp . Foo

    Where Foo.java is the hello world program

82. 
Print a list using forEach
    list.forEach(System.out::println);

83.
How to convert Java String into byte[]?
http://stackoverflow.com/questions/18571223/how-to-convert-java-string-into-byte

    byte[] b = string.getBytes();
    byte[] b = string.getBytes(Charset.forName("UTF-8"));
    byte[] b = string.getBytes(StandardCharsets.UTF_8); // Java 7+ only

83b.
Convert integer into byte array (Java)

    ByteBuffer b = ByteBuffer.allocate(4);
    //b.order(ByteOrder.BIG_ENDIAN); // optional, the initial order of a byte buffer is always BIG_ENDIAN.
    b.putInt(0xAABBCCDD);

    byte[] result = b.array();

84.
Is there an equivalent to memcpy() in Java?
http://stackoverflow.com/questions/3329163/is-there-an-equivalent-to-memcpy-in-java

		byte[] src = {1, 2, 3, 4};
		byte[] dst = Arrays.copyOf(src, src.length);
		System.out.println(Arrays.toString(dst));

	OR
		Use System.arraycopy()

		System.arraycopy(sourceArray, 
						 sourceStartIndex,
						 targetArray,
						 targetStartIndex,
						 length);
		Example,

			  String[] source = { "alpha", "beta", "gamma" };
			  String[] target = new String[source.length];
			  System.arraycopy(source, 0, target, 0, source.length);

85.
Print an integer in binary format in Java
http://stackoverflow.com/questions/5263187/print-an-integer-in-binary-format-in-java

	int x = 100;
	System.out.println(Integer.toBinaryString(x));

	Integer.toString(100,8) // prints 144 --octal representation
	Integer.toString(100,2) // prints 1100100 --binary representation
	Integer.toString(100,16) //prints 64 --Hex representation

86.
Converting Little Endian to Big Endian
http://stackoverflow.com/questions/3842828/converting-little-endian-to-big-endian

	int little2big(int i) {
		return (i&0xff)<<24 | (i&0xff00)<<8 | (i&0xff0000)>>8 | (i>>24)&0xff;
	}

87.
StringBuilder vs String
http://stackoverflow.com/questions/1532461/stringbuilder-vs-string-concatenation-in-tostring-in-java

    Use StringBuilder when concatenating Strings inside a loop
    Compiler will take care of String concatenation outside the loop

88.
How to read an unknown number of bytes from an inputStream (socket/socketServer)?
http://stackoverflow.com/questions/5690954/java-how-to-read-an-unknown-number-of-bytes-from-an-inputstream-socket-socke

    byte[] resultBuff = new byte[0];
    byte[] buff = new byte[1024];
    int k = -1;
    while((k = sock.getInputStream().read(buff, 0, buff.length)) > -1) {
        byte[] tbuff = new byte[resultBuff.length + k]; // temp buffer size = bytes already read + bytes last read
        System.arraycopy(resultBuff, 0, tbuff, 0, resultBuff.length); // copy previous bytes
        System.arraycopy(buff, 0, tbuff, resultBuff.length, k);  // copy current lot
        resultBuff = tbuff; // call the temp buffer as your result buff
    }
    System.out.println(resultBuff.length + " bytes read.");
    return resultBuff;

89.
Receive byte[] using ByteArrayInputStream from a socket
http://stackoverflow.com/questions/10475898/receive-byte-using-bytearrayinputstream-from-a-socket

    InputStream stream = socket.getInputStream();
    byte[] data = new byte[100];
    int count = stream.read(data);

90.
How can I convert a 4-byte array to an integer?
http://stackoverflow.com/questions/5616052/how-can-i-convert-a-4-byte-array-to-an-integer

    Big-endian:
    int x = java.nio.ByteBuffer.wrap(bytes).getInt();

    Little-endian:
    int x = java.nio.ByteBuffer.wrap(bytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt();

91.
Java ByteBuffer to String

    StandardCharsets.UTF_8

    To get the bytes from a String in a particular encoding, you can use a sibling getBytes() method:
      byte[] bytes = k.getBytes( Charset.forName("UTF-8" ));

    To put bytes with a particular encoding into a String, you can use a different String constructor:
       String v = new String( bytes, Charset.forName("UTF-8") );

92.
How to convert a String into an ArrayList?

    List<String> myList = new ArrayList<String>(Arrays.asList(s.split(",")));

93.
Default values to arguments in function
    
    Java does not have a way to do it

94.
Static classes in Java
    
    Can't create static classes without public

95.
What is try-with-resources

    It was introduced because of some resources used in Java (like SQL connections or streams) being difficult to be handled properly;
    as an example, in java 6 to handle a InputStream properly you had to do something like:
        InputStream stream = new MyInputStream(...);
        try {
            // ... use stream
        } catch(IOException e) {
           // handle exception
        } finally {
            try {
                if(stream != null) {
                    stream.close();
                }
            } catch(IOException e) {
                // handle yet another possible exception
            }
        }

    Do you notice that ugly double try? now with try-with-resources you can do this:
        try (InputStream stream = new MyInputStream(...)){
            // ... use stream
        } catch(IOException e) {
           // handle exception
        }
    and close() is automatically called, if it throws an IOException

96.
Sort list of strings

97. Using enum

    private enum Color {
        RED("RED"),
        BLUE("BLUE");

        private final String color;

        private Color(String val) {
            this.color = val;
        }

        public String getColor() {
            return color;
        }
    }

    main() {
        String s = "RED";
        System.out.println(Color.valueOf(s));

        String strColor = Color.RED.name();
        Color enumColor = Color.valueOf(s);

        switch (enumColor) {
            case RED:
                System.out.println("Color is RED");
                break;
            case BLUE:
                System.out.println("Color is BLUE");
                break;
            default:
                System.out.println("Color is Invalid");
                break;
        }
    }

98. Collection.containsAll()
    String elements[] = { "A", "B", "C", "D", "E" };
    Set set = new HashSet(Arrays.asList(elements));

    elements = new String[] { "A", "B", "C" };
    Set set2 = new HashSet(Arrays.asList(elements));

    System.out.println(set.containsAll(set2));

99. Add a list in a hashset using addAll
	List<Integer> a = new ArrayList<Integer>();
	a.add(20);

	List<Integer> b = new ArrayList<Integer>();
	b.add(30);

	Set<Integer> set = new HashSet<Integer>(a);
	set.addAll(b);

100. Convert list to a set
	Set<Foo> foo = new HashSet<Foo>(myList);

101. Comparing and removing elements not present in a List and array java
    You can use the methods the List interface provides.
    list.removeAll(Arrays.asList(array)); // Differences removed
    list.retainAll(Arrays.asList(array)); // Same elements retained

102. Convert List<String> to List<Integer> directly
    stringList.stream().map(Integer::parseInt).collect(Collectors.toList());

103. Communication between java threads: stopping all threads when one finishes its task
    https://stackoverflow.com/questions/17166918/communication-between-java-threads-stopping-all-threads-when-one-finishes-its-t
    https://stackoverflow.com/questions/19480162/java-threads-close-other-threads-when-first-thread-completes

104. Multithreading - Callable vs Runnable and Future
    http://www.geeksforgeeks.org/callable-future-java/
    http://www.concretepage.com/java/java-callable-example
    http://javarevisited.blogspot.com/2015/06/how-to-use-callable-and-future-in-java.html
    http://howtodoinjava.com/core-java/multi-threading/threadpoolexecutor-callable-future-example/

    There are two ways of creating threads – one by extending the Thread class and other by creating a thread with a Runnable. However, one feature lacking in  Runnable is that we cannot make a thread return result when it terminates, i.e. when run() completes. For supporting this feature, the Callable interface is present in Java.


    1. For implementing Runnable, the run() method needs to be implemented which does not return anything, while for a Callable, the call() method needs to be implemented which returns a result on completion. Note that a thread can’t be created with a Callable, it can only be created with a Runnable
    2. Another difference is that the call() method can throw an exception whereas run() cannot.


104b1. Multithreading - “implements Runnable” vs. “extends Thread”
    https://stackoverflow.com/questions/541487/implements-runnable-vs-extends-thread
    
    Implements Runnable is the preferred way to do it, IMO. You're not really specialising the thread's behaviour. You're just giving it something to run. That means composition is the philosophically "purer" way to go.

    Caveat: Around here, I strongly discourage the use of raw Threads. I much prefer the use of Callables and FutureTasks (From the javadoc: "A cancellable asynchronous computation"). The integration of timeouts, proper cancelling and the thread pooling of the modern concurrency support are all much more useful to me than piles of raw Threads.

    Follow-up: there is a FutureTask constructor that allows you to use Runnables (if that's what you are most comfortable with) and still get the benefit of the modern concurrency tools. To quote the javadoc:

    Moral of the story:
    Inherit only if you want to override some behavior.
    Or rather it should be read as:
    Inherit less, interface more.

104b2. Creating new Threads
http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html
    Creating a thread in Java is done like this:
       Thread thread = new Thread();

    To start the Java thread you will call its start() method, like this:
        thread.start();

    Method 1:
        public class MyThread extends Thread {
            public void run(){
               System.out.println("MyThread running");
            }
        }

        MyThread myThread = new MyThread();
        myTread.start();

    You can also create an anonymous subclass of Thread like this:
        Thread thread = new Thread(){
            public void run(){
              System.out.println("Thread Running");
            }
        }
        thread.start();

    Method 2:
        public class MyRunnable implements Runnable {
            public void run(){
               System.out.println("MyRunnable running");
            }
        }
        Thread thread = new Thread(new MyRunnable());
        thread.start();

    You can also create an anonymous implementation of Runnable, like this:
        Runnable myRunnable = new Runnable(){
            public void run(){
                System.out.println("Runnable running");
            }
        }
        Thread thread = new Thread(myRunnable);
        thread.start();

    Using Lambda:
http://www.codejava.net/java-core/the-java-language/java-8-lambda-runnable-example
    // Lambda Runnable
    Runnable task2 = () -> { System.out.println("Runnable running"); };
     
     // start the thread
     new Thread(task2).start();
104c. CountdownLatch
http://www.geeksforgeeks.org/countdownlatch-in-java/
https://stackoverflow.com/questions/17827022/how-is-countdownlatch-used-in-java-multithreading
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html

    A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.

    A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.

    A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown(). A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.

    A useful property of a CountDownLatch is that it doesn't require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. 

104d. Thread Signaling - wait(), notify() and notifyAll()
http://tutorials.jenkov.com/java-concurrency/thread-signaling.html
    A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object. In order to call either wait() or notify the calling thread must first obtain the lock on that object. In other words, the calling thread must call wait() or notify() from inside a synchronized block.

        public class MonitorObject{
        }

        public class MyWaitNotify{

          MonitorObject myMonitorObject = new MonitorObject();

          public void doWait(){
            synchronized(myMonitorObject){
              try{
                myMonitorObject.wait();
              } catch(InterruptedException e){...}
            }
          }

          public void doNotify(){
            synchronized(myMonitorObject){
              myMonitorObject.notify();
            }
          }
        }

    Missed Signals
    The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called. The notify signal is then just lost. Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread. This may or may not be a problem, but in some cases this may result in the waiting thread waiting forever, never waking up, because the signal to wake up was missed.

    Spurious Wakeups
    For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called. This is known as spurious wakeups. Wakeups without any reason.

    If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so! This could cause serious problems in your application.

    To guard against spurious wakeups the signal member variable is checked inside a while loop instead of inside an if-statement. Such a while loop is also called a spin lock.

    As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block. This is mandatory! A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on. If it does, an IllegalMonitorStateException is thrown.

	Facts about CountDownLatch:

    Creating an object of CountDownLatch by passing an int to its constructor (the count), is actually number of invited parties (threads) for an event.
    The thread, which is dependent on other threads to start processing, waits on until every other thread has called count down. All threads, which are waiting on await() proceed together once count down reaches to zero.
    countDown() method decrements the count and await() method blocks until count == 0


105. Difference between Arrays.asList(array) vs new ArrayList<Integer>(Arrays.asList(ia)) in java
https://stackoverflow.com/questions/16748030/difference-between-arrays-aslistarray-vs-new-arraylistintegerarrays-aslist

    First, let's see what this does:

    Arrays.asList(ia)
    It takes an array ia and creates a wrapper that implements List<Integer>, which makes the original array available as a list. Nothing is copied and all, only a single wrapper object is created. Operations on the list wrapper are propagated to the original array. This means that if you shuffle the list wrapper, the original array is shuffled as well, if you overwrite an element, it gets overwritten in the original array, etc. Of course, some List operations aren't allowed on the wrapper, like adding or removing elements from the list, you can only read or overwrite the elements.

    Note that the list wrapper doesn't extend ArrayList - it's a different kind of object. ArrayLists have their own, internal array, in which they store their elements, and are able to resize the internal arrays etc. The wrapper doesn't have its own internal array, it only propagates operations to the array given to it.
    On the other hand, if you subsequently create a new array as

    new ArrayList<Integer>(Arrays.asList(ia))
    then you create new ArrayList, which is a full, independent copy of the original one. Although here you create the wrapper using Arrays.asList as well, it is used only during the construction of the new ArrayList and is garbage-collected afterwards. The structure of this new ArrayList is completely independent of the original array. It contains the same elements (both the original array and this new ArrayList reference the same integers in memory), but it creates a new, internal array, that holds the references. So when you shuffle it, add, remove elements etc., the original array is unchanged.


106. Can I compile a java file with a different name than the class?
https://stackoverflow.com/questions/1841847/can-i-compile-a-java-file-with-a-different-name-than-the-class
    Your Java file name should always reflect the public class defined within that file. Otherwise, you will get a compiler error. For example, test.java:

    public class Foo {}
    Trying to compile this gives:

    [steven@scstop:~]% javac test.java
    test.java:1: class Foo is public, should be declared in a file named Foo.java
    public class Foo {
           ^
           1 error

	But the myth can be violated in such a way to compile the above file.
	/***** File name: Trial.java ******/
	class Geeks
	{
		public static void main(String[] args) {
			System.out.println("Hello world");
		}
	}
	Run on IDE
	Step 1: javac Trial.java
	Step1 will create a Geeks.class (byte code) without any error message since the class is not public.

	Step 2: java Geeks
	Now the output will be Hello world

	The myth about the file name and class name should be same only when the class is declared in public.

107. Is main method compulsory in Java

    Prior to JDK 5, main method was not mandatory in a java program.

    You could write your full code under static block and it ran normally.
    The static block is first executed as soon as the class is loaded before the main(); method is invoked and therefore before the main() is called. main is usually declared as static method and hence Java doesn’t need an object to call main method.
     
     However, From JDK6 main method is mandatory. If your program doesn’t contain main method, then you will get a run-time error “main method not found in the class”. Note that your program will successfully compile in this case, but at run-time, it will throw error.

	// This program will successfully run
	// prior to JDK 5
	public class Test 
	{
		// static block
		static
		{
			System.out.println("program is running without main() method");
		}
	}

108. Java Data structures:

                Add         Get             Remove          Update      isPresent       Size        isEmpty     Clear
ArrayList       add         get                             set         indexOf         size        isEmpty     clear
Stack           push        pop/peek                                    search          size        empty
Queue           add/offer   element/peek   remove/poll                                              isEmpty
PiorityQueue    add/offer   peek           remove/poll                  contains        size        isEmpty     clear
LinkedList      add/offer   element/peek   remove/poll                                              isEmpty
HashSet         add                        remove                       contains        size        isEmpty     clear
HashMap         put         get            remove           put         containsKey     size        isEmpty     clear
LinkedHashMap   put         get            remove           put         containsKey     size        isEmpty     clear

String: chatAt, equals, compareTo, indexOf, isEmpty, length, valueOf, substring, startsWith, split
Arrays: asList, binarySearch, fill, equals, sort


    1. Arrays
        a. arr.length;

    2. ArrayList
        a. add(E e)
        b. add(int index, E element)
        c. addAll(Collection<? extends E> c)
        d. clear()
        e. contains(Object o)
        f. get(int index)
        g. indexOf(Object o)
        h. isEmpty()
        i. lastIndexOf(Object o)
        j. remove(int index)
        k. remove(Object o)
        l. toArray()

    3. HashMap
           HashMap<Integer, Integer> sumMap = new HashMap<>();
        a. clear()
        b. containsKey(Object key)
        c. containsValue(Object value)
        d. entrySet()
        e. get(Object key)
        f. isEmpty()
        g. put(K key, V value)
        h. remove(Object key)
        i. remove(Object key, Object value)
           // Removes the entry for the specified key only if it is currently mapped to the specified value.
        j. Map.Entry<KeyType, ValueType> e : map.entrySet()
               e.getKey(), e.getValue()

    4. HashSet
        a. add(E e)
        b. clear()
        c. contains(Object o)
        d. isEmpty()
        e. remove(Object o)

    5. PriorityQueue
           PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        a. add(E e)
        b. clear()
        c. comparator()
        d. contains(Object o)
        e. offer(E e) // Does not throw an exception
        e. add(E e) // https://stackoverflow.com/questions/2703984/what-is-the-difference-between-the-add-and-offer-methods-in-a-queue-in-java
        f. peek()
        g. poll()
        h. remove(Object o)
        i. toArray()

    6. Queue
        a. queue.add() // Throws exception
        b. queue.remove() // Throws exception
        c. queue.element() // Get first element
        d. queue.isEmpty()
        d. queue.poll() // Does not throw exception

    I guess the difference is in the contract, that when element can not be added to collection the add method throws an exception and offer doesn't.

    If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.

    Inserts the specified element into this queue, if possible. When using queues that may impose insertion restrictions (for example capacity bounds), method offer is generally preferable to method Collection.add(E), which can fail to insert an element only by throwing an exception.

    7. Stack
        a. st.push()
        b. st.pop()
        c. st.peek()
        d. st.empty()
    8. LinkedHashMap
        a. lhm.put()
        b. lhm.containsKey()
        c. lhm.get()
        d. lhm.entrySet()
    9. LinkedList
        a. ll.add()
        b. ll.getFirst()
        c. ll.getLast()
    10. Google Multimap
           Multimap<Integer, Integer> sumMap = HashMultimap.create();
    BitSet

109. Difference between int[] array and int array[]
    The [] is part of the TYPE, not of the NAME. For me, that's the biggest difference
    int[] a, b;  // Both a and b are arrays of type int
    int c[], d;  // WARNING: c is an array, but d is just a regular int


110. How to fill an array with certain value (zero fill)
    A default value of 0 for arrays of integral types is guaranteed by the language spec:
        Each class variable, instance variable, or array component is initialized with a default value when it is created (§15.9, §15.10) [...] For type int, the default value is zero, that is, 0.  
    If you want to initialize an array to a different value, you can use java.util.Arrays.fill() (which will of course use a loop internally).

110b. How can I initialize an ArrayList with all zeroes in Java?
https://stackoverflow.com/questions/5600668/how-can-i-initialize-an-arraylist-with-all-zeroes-in-java
    Q.
    It looks like arraylist is not doing its job for presizing:
    // presizing 
    ArrayList<Integer>() list = new ArrayList<Integer>(60);

    Afterwards when I try to access it:
    list.get(5) 

    It shows null instead of 0

    A.
    The integer passed to the constructor represents its initial capacity, i.e., the number of elements it can hold before it needs to resize its internal array (and has nothing to do with the initial number of elements in the list).

    To initialize an list with 60 zeros you do:
    List<Integer> list = new ArrayList<Integer>(Collections.nCopies(60, 0));

    If you want to create a list with 60 different objects, you could use the Stream API with a Supplier as follows:
    List<Person> persons = Stream.generate(Person::new)
                                 .limit(60)
                                 .collect(Collectors.toList());


111. How do I declare and initialize an array in Java?
    https://stackoverflow.com/questions/1200621/how-do-i-declare-and-initialize-an-array-in-java

    For primitive types:
    int[] myIntArray = new int[3];
    int[] myIntArray = {1,2,3};
    int[] myIntArray = new int[]{1,2,3};

    For classes, for example String, it's the same:
    String[] myStringArray = new String[3];
    String[] myStringArray = {"a","b","c"};
    String[] myStringArray = new String[]{"a","b","c"};

    The third way of initialising is useful when you declare the array first and then initialise it. Cast is necessary here.
    String[] myStringArray;
    myStringArray = new String[]{"a","b","c"};

112. Setting initial capacity to array list
    For arrays you will do, 
        int[] a = new int[5];

    Q1.
    You can set the initial size for an ArrayList by doing
        ArrayList<Integer> arr=new ArrayList<Integer>(10);
        However, you can't do
        arr.add(5, 10);

    A1.
    You're confusing the size of the array list with its capacity:
         - the size is the number of elements in the list;
         - the capacity is how many elements the list can potentially accommodate without reallocating its internal structures.
        When you call new ArrayList<Integer>(10), you are setting the list's initial capacity, not its size. In other words, when constructed in this manner, the array list starts its life empty.

    Q2.
    Is there a way of setting the size of an arraylist after declaring it?
        For example, in a traditional array, i would declare an array like this:
        int array[];

        then, i would later initialize it like this
        array = new int[1000];

        in an arraylist i am trying to do the same but I have only been able to initialize it while declaring it like below.
        ArrayList<String> array = new ArrayList<>(1000);

    A2.
    You can use ensureCapacity(int)
    ArrayList<Integer> al = new ArrayList<>();
    al.ensureCapacity(1000);

    It is important to note that array lists WILL dynamically resize themselves though.
    So I would like to know if there's a way to initialize an arraylist to for example 1000 after it's been declared in a separate statement.

    You could always do this, too:
    ArrayList<Integer> al;
    al = new ArrayList<Integer>(1000);
    
113. Java Streams
http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/

    int sum = list.stream().mapToInt(Integer::intValue).sum();
    int sum = IntStream.of(a).sum();

114. Static nested class in Java, why
https://stackoverflow.com/questions/253492/static-nested-class-in-java-why
TIJ - 4th edition

    A nested class is a member of its enclosing class. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class.

    Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.

	Top-level classes can't be declared static, only nested classes can be:
	class OuterClass {
		...
		static class StaticNestedClass {
			...
		}
		class InnerClass {
			...
		}
	}

	The difference is that:
		non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private;
		static nested classes do not have access to other members of the enclosing class.

    A nested class means:
    1. You don’t need an outer-class object inorder to create an object of a nested class
    2. You can’t access a non-static outer-class object from an object of a nested class
    Nested classes are different from ordinary inner classes in another way, as well. Fields and methods in ordinary inner classes can only be at the outer level of a class, so ordinary inner classes cannot have static data, static fields, or nested classes. However, nested classes can have all of these

    Normally, you can’t put any code inside an interface, but a nested class can be part of an interface. Any class you put inside an interface is automatically public and static. Since the class is static, it doesn’t violate the rules for interfaces—the nested class is only placed inside the namespace of the interface. You can even implement the surrounding interface in the inner class

114b. Java inner class and static nested class
https://stackoverflow.com/questions/70324/java-inner-class-and-static-nested-class

	From the Java Tutorial:
	Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are simply called static nested classes. Non-static nested classes are called inner classes.
	Static nested classes are accessed using the enclosing class name:

	OuterClass.StaticNestedClass
	For example, to create an object for the static nested class, use this syntax:

	OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
	Objects that are instances of an inner class exist within an instance of the outer class. Consider the following classes:

	class OuterClass {
		...
		class InnerClass {
			...
		}
	}
	An instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance.

	To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:

	OuterClass.InnerClass innerObject = outerObject.new InnerClass();
	see: Java Tutorial - Nested Classes

	For completeness note that there is also such a thing as an inner class without an enclosing instance:

	class A {
	  int t() { return 1; }
	  static A a =  new A() { int t() { return 2; } };
	}
	Here, new A() { ... } is an inner class defined in a static context and does not have an enclosing instance.

115. ExecutorService Shutdown
http://tutorials.jenkov.com/java-util-concurrent/executorservice.html
https://stackoverflow.com/questions/18425026/shutdown-and-awaittermination-which-first-call-have-any-difference

    When you are done using the ExecutorService you should shut it down, so the threads do not keep running.

    For instance, if your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application. The active threads inside this ExecutorService prevents the JVM from shutting down.

    To terminate the threads inside the ExecutorService you call its shutdown() method. The ExecutorService will not shut down immediately, but it will no longer accept new tasks, and once all threads have finished current tasks, the ExecutorService shuts down. All tasks submitted to the ExecutorService before shutdown() is called, are executed.

    If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method. This will attempt to stop all executing tasks right away, and skips all submitted but non-processed tasks. There are no guarantees given about the executing tasks. Perhaps they stop, perhaps the execute until the end. It is a best effort attempt.

shutdown and awaitTermination which first call have any difference?
    You should call shutdown first. Otherwise, you might be waiting for a very long time, since awaitTermination doesn't actually shut down your executor.

    If you wanted to wait for tasks to complete, rather than wait for the executor to shut down, then you should use invokeAll

116. Catch multiple exceptions
    catch (IOException | SQLException ex)

117. Concatenate strings using System.out.println
https://stackoverflow.com/questions/11035026/system-out-printlnabc32-why-output-is-abc32-and-not-abc5
    Q:
    System.out.println("abc"+3+2); // Output: abc32
    System.out.println(3+2+"abc"); //Output: 5abc

    A:
    "abc"+3
    converts 3 to a String

    "abc3"
    Then

    "abc3" + 2
    Converts 2 to a String as well

    "abc32"
    To get a numeric result do

    "abc" + (3 + 2)

118. Create array of certain size such that it can't grow beyond that
https://stackoverflow.com/questions/5196113/any-way-to-set-max-size-of-a-collection

        // In the below list "add" and "remove" won't work
        List<Integer> bl = Arrays.asList(new Integer[3]);
        // bl.add(5); // This throws UnsupportedOperationException
        bl.set(0, 6);
        bl.set(1, 7);
        bl.set(2, 8);
        // bl.set(3, 9); // This gives ArrayIndexOutOfBoundsException
 
119. How can I pass a parameter to a Java Thread
https://stackoverflow.com/questions/877096/how-can-i-pass-a-parameter-to-a-java-thread

    You need to pass the parameter in the constructor to the thread object:
        public class MyThread implements Runnable {
           public MyThread(Object parameter) {
               // store parameter for later user
           }

           public void run() {
           }
        }

    and invoke it thus:
        Runnable r = new MyThread(param_value);
        new Thread(r).start();

120. Java Blocking Queue
https://www.journaldev.com/1034/java-blockingqueue-example
http://javarevisited.blogspot.com/2012/02/producer-consumer-design-pattern-with.html

    BlockingQueue put() method will block if Queue is full in case of Bounded Queue and take() will block if Queue is empty.

    Java BlockingQueue doesn’t accept null values and throw NullPointerException if you try to store null value in the queue.
    Java BlockingQueue implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.
    Java provides several BlockingQueue implementations such as ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue etc.

121. Default Methods In Java
http://www.geeksforgeeks.org/default-methods-java/

    Java 8 introduces “Default Method” or (Defender methods) new feature, which allows developer to add new methods to the interfaces without breaking the existing implementation of these interface.
    It provides flexibility to allow interface define implementation which will use as default in the situation where a concrete class fails to provide an implementation for that method.

    Why Defaut Method?
        Reengineering an existing JDK framework is always very complex. Modify one interface in JDK framework breaks all classes that extends the interface which means that adding any new method could break millions of lines of code. Therefore, default methods have introduced as a mechanism to extending interfaces in a backward compatible way.

        Default methods can be provided to an interface without affecting implementing classes as it includes an implementation. 

        // A simple program to Test Interface default
        // methods in java
        interface TestInterface {
            // abstract method
            public void square(int a);
         
            // default method
            default void show() {
              System.out.println("Default Method Executed");
            }
        }
         
        class TestClass implements TestInterface {
            // implementation of square abstract method
            public void square(int a) {
                System.out.println(a*a);
            }
         
            public static void main(String args[]) {
                TestClass d = new TestClass();
                d.square(4);
         
                // default method executed
                d.show();
            }
        }

122. Interface with default methods vs Abstract class in Java 8
https://stackoverflow.com/questions/19998454/interface-with-default-methods-vs-abstract-class-in-java-8

    There's a lot more to abstract classes than default method implementations (such as private state), but as of Java 8, whenever you have the choice of either, you should go with the defender (aka. default) method in the interface.

    The constraint on the default method is that it can be implemented only in the terms of calls to other interface methods, with no reference to a particular implementation's state. So the main use case is higher-level and convenience methods.

    The good thing about this new feature is that, where before you were forced to use an abstract class for the convenience methods, thus constraining the implementor to single inheritance, now you can have a really clean design with just the interface and a minimum of implementation effort forced on the programmer.

    These two are quite different:
    - Default methods are to add external functionality to existing classes without changing their state.
    - And abstract classes are a normal type of inheritance, they are normal classes which are intended to be extended.
        
    There are a few technical differences. Abstract classes can still do more in comparison to Java 8 interfaces:
        Abstract class can have a constructor.
        Abstract classes are more structured and can hold a state.
    Conceptually, main purpose of defender methods is a backward compatibility after introduction of new features (as lambda-functions) in Java 8.

123. Default Method and Multiple Inheritance Ambiguity Problems
https://dzone.com/articles/interface-default-methods-java

    Since java class can implement multiple interfaces and each interface can define default method with same method signature, therefore, the inherited methods can conflict with each other.

123. Java Scanner vs BufferedReader
https://stackoverflow.com/questions/17637032/bufferedreader-vs-console-vs-scanner

    Scanner is used for parsing tokens from the contents of the stream while BufferedReader just reads the stream and does not do any special parsing.
    As to the choice, use the Scanner if you want to parse the file, use the BufferedReader if you want to read the file line by line.

    A scanner on the other hand has a lot more cheese built into it; it can do all that a BufferedReader can do and at the same level of efficiency as well. However, in addition a Scanner can parse the underlying stream for primitive types and strings using regular expressions. It can also tokenize the underlying stream with the delimiter of your choice. It can also do forward scanning of the underlying stream disregarding the delimiter!
    A scanner however is not thread safe, it has to be externally synchronized.

    Even while reading the input, if want to accept user input line by line and say just add it to a file, a BufferedReader is good enough. On the other hand if you want to accept user input as a command with multiple options, and then intend to perform different operations based on the command and options specified, a Scanner will suit better.

    BufferedReader
        Since Java 1.1
        Throws checked exceptions
        Can read chars, char arrays, and lines
        Fast

    Scanner
        Since Java 1.5
        Doesn't throw checked exceptions
        Can read lines, whitespace-delimited tokens, regex-delimited tokens, and numbers
        Difficult to read single characters

    Console
        Since Java 1.6
        Doesn't throw checked exceptions
        Can read lines
        Underlying reader can read chars and char arrays (stops at line bounds)
        Not always available (e.g. Eclipse)
        Can read passwords (i.e. read without displaying the characters)

    Recommendation: Scanner
    The methods for reading numbers are very useful. The exceptions are unchecked, so you do not have to write boilerplate try/catch blocks.

124. Scanner method to get a char
https://stackoverflow.com/questions/2597841/scanner-method-to-get-a-char/2597939#2597939

    To get a char from a Scanner, you can use the findInLine method.

        Scanner sc = new Scanner("abc");
        char ch = sc.findInLine(".").charAt(0);
        System.out.println(ch); // prints "a"
        System.out.println(sc.next()); // prints "bc"

    If you need a bunch of char from a Scanner, then it may be more convenient to (perhaps temporarily) change the delimiter to the empty string. This will make next() returns a length-1 string every time.
        Scanner sc = new Scanner("abc");
        sc.useDelimiter("");
        while (sc.hasNext()) {
            System.out.println(sc.next());
        } // prints "a", "b", "c"

125. Scanner is skipping nextLine() after using next(), nextInt() or other nextFoo()?
https://stackoverflow.com/questions/13102045/scanner-is-skipping-nextline-after-using-next-nextint-or-other-nextfoo

    That's because the Scanner.nextInt method does not consume the last newline character of your input, and thus that newline is consumed in the next call to Scanner.nextLine.

    You will encounter the similar behaviour when you use Scanner.nextLine after Scanner.next() or any Scanner.nextFoo method (except nextLine itself).

    Workaround:
        Either fire a blank Scanner.nextLine call after Scanner.nextInt or Scanner.nextFoo to consume rest of that line including newline
            int option = input.nextInt();
            input.nextLine();  // Consume newline left-over
            String str1 = input.nextLine();

        Or, it would be even better, if you read the input through Scanner.nextLine and convert your input to the proper format you need. For examples, to an integer using Integer.parseInt(String) method.
            int option = 0;
            try {
                option = Integer.parseInt(input.nextLine());
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
            String str1 = input.nextLine();

126. Read array using Scanner and BufferedReader
https://stackoverflow.com/questions/14635136/read-integers-separated-with-whitespace-into-int-array

You could use Scanner:
    Scanner scanner = new Scanner(System.in);
    List<Integer> list = new ArrayList<Integer>();
    while (scanner.hasNextInt())
      list.add(scanner.nextInt());
    int[] arr = list.toArray(new int[0]);

BufferedReader is Faster then Scanner
    Using BufferedReader and then splitting and parsing each Integer value is much Faster then using nextInt() method of Scanner.

        BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));
        int num[] = new int[1000];
        String[] strNums;    
        strNums = bi.readLine().split("\\s");
        for(int i=0; i<strNums.length; i++) {
            num[i] = Integer.parseInt(strNums[i]);
        }

127. Read multiple lines from console

        List<String> lines = new ArrayList<>();
        Scanner s = new Scanner(System.in);
        while (s.hasNextLine()) {
            String line = s.nextLine();
            if (line.isEmpty()) {
                break;
            }
            lines.add(line);
        }

128a. Find index of String in another string
    String.indexOf(String str)
    Boolean found = text.contains(word);

128b. Get substring from String / StringBuilder
    line.substring(line.indexOf("//") + 1);

128c. Java indexOf method for multiple matches in String
    i = str.indexOf('x');
    while(i >= 0) {
         System.out.println(i);
         i = str.indexOf('x', i+1);
    }

129. How can I clear or empty a StringBuilder?
    stringBuilderObj.setLength(0)

130. What is the best way to tell if a character is a letter or number in Java without using regexes?
    private static boolean isLetterOrDigit(char c) {
        return (c >= 'a' && c <= 'z') ||
               (c >= 'A' && c <= 'Z') ||
               (c >= '0' && c <= '9');
    }

131. How to match letters only using java regex, matches method?
    String s = "abcdefà";
    Pattern p = Pattern.compile("[^a-zA-Z0-9]");
    boolean hasSpecialChar = p.matcher(s).find();

132. Don't assign one list to another
    If you do, then modifying one list will modify another list too

    1.
    ArrayList<String> newArrayList = (ArrayList<String>) oldArrayList.clone();

    2.
    List<String> strs;
    ...
    List<String> newStrs = new ArrayList<>(strs);

    3.
    List<String> list2 = list1.stream().collect(Collectors.toList());

133. How to sort Map values by key in Java
https://stackoverflow.com/questions/922528/how-to-sort-map-values-by-key-in-java

    Use a TreeMap. This is precisely what its for.

    Remember when using a TreeMap or TreeSet that it will have different performance characteristics than HashMap or HashSet. Roughly speaking operations that find or insert an element will go from O(1) to O(Log(N)).

    Assuming TreeMap is not good for you (and assuming you can't use generics):
        List sortedKeys=new ArrayList(yourMap.keySet());
        Collections.sort(sortedKeys);
        // Do what you need with sortedKeys.

134. Arrays.fill with multidimensional array in Java
    // Fill each row with 1.0
    for (double[] row: matrix)
        Arrays.fill(row, 1.0);

135. Implement Comparator function
https://stackoverflow.com/questions/5805602/how-to-sort-list-of-objects-by-some-property
        Collections.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval a, Interval b) {
                return a.start > b.start ? 1 : a.start < b.start ? -1 : 0;
            }
        });

    Either make ActiveAlarm implement Comparable<ActiveAlarm> or implement Comparator<ActiveAlarm> in a separate class. Then call:
        Collections.sort(list);
    or
        Collections.sort(list, comparator);

    In general, it's a good idea to implement Comparable<T> if there's a single "natural" sort order... otherwise (if you happen to want to sort in a particular order, but might equally easily want a different one) it's better to implement Comparator<T>. This particular situation could go either way, to be honest... but I'd probably stick with the more flexible Comparator<T> option

136. Possible Lossy conversion from long to int
    Array index is an integer in Java and the compiler will advice you. So maximum array size is (aproximately) Integer.MAX_VALUE. For bigger arrays you should use ArrayList.

137. How do I convert from int to Long in Java?
    Note that there is a difference between a cast to long and a cast to Long. If you cast to long (a primitive value) then it should be automatically boxed to a Long (the reference type that wraps it)

    Long.valueOf(int);

138. Do containsAll() and retainAll() in the Collection interface address cardinality?
    No

    Using containsAll(). This option is not ideal, in my opinion, because it offers worst case performance, O(n^2).

    There are two variations to this:
    2a) If you don't care about maintaining the order ofyour lists... use Collections.sort() on both list. Then use the equals(). This is O(nlogn), because you do two sorts, and then an O(n) comparison.

139. Simple way to find if two different lists contain exactly the same elements?
    If you care about order, then just use the equals method:
        list1.equals(list2)

140. CompareTo with primitives -> Integer / int
    Integer.compare(int, int)

    int cmp = a > b ? +1 : a < b ? -1 : 0;

140. Java: is there an easy way to select a subset of an array?
    Arrays.copyOfRange(array, 1, array.length);

141. Initialization of an ArrayList in one line
    Actually, probably the "best" way to initialize the ArrayList is the method you wrote, as it does not need to create a new List in any way:
        ArrayList<String> list = new ArrayList<String>();
        list.add("A");
        list.add("B");
        list.add("C");

142. How to convert int[] into List<Integer> in Java?

    There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> which is not what you want. You have to make a utility method.

        int[] ints = {1, 2, 3};
        List<Integer> intList = new ArrayList<Integer>();
        for (int index = 0; index < ints.length; index++)
        {
            intList.add(ints[index]);
        }


    Actually, probably the "best" way to initialize the ArrayList is the method you wrote, as it does not need to create a new List in any way:
        ArrayList<String> list = new ArrayList<String>();
        list.add("A");
        list.add("B");
        list.add("C");

143. How to set a default value for items list / array?

    Integer[] integers = new Integer[10];
    Arrays.fill(integers, 0);

    Collections.nCopies is your friend if you need a list instead of an array:
        List<Integer> list = Collections.nCopies(10, 0);
    If a mutable list is needed, wrap it:
        List<Integer> list = new ArrayList<>(Collections.nCopies(10, 0));

144. Get Size of data types
    Since Java 8, all wrapper classes of primitive types (except Boolean) have a BYTES field
        Double.BYTES 
        Integer.BYTES

    Pre Java 8 - Get size in bits and conver to bytes
        Double.SIZE / Byte.SIZE
        Integer.SIZE / Byte.SIZE

145. Remove last character from String and StringBuilder
    sb.setLength(sb.length() - 1);
    str = str.substring(0, str.length() - 1);

146. Convert int to int array
        String temp = Integer.toString(guess);
        int[] newGuess = new int[temp.length()];
        for (int i = 0; i < temp.length(); i++)
        {
            newGuess[i] = temp.charAt(i) - '0';
        }

147. Change char in a StringBuilder
    setCharAt()

148. String equals
    == tests for reference equality (whether they are the same object).
    .equals() tests for value equality (whether they are logically "equal").

149. String.charAt() goes out of bound if index is beyond string length
