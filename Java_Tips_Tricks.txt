1. Why Java uses Heap instead of Stack
2. Access Specifiers
3. Early Binding
4. Object Base Class
5. What are Generics in Java
6. Heap and Stack Storage
7. How Garbage Collector Works
8. How JVM works
9. What is Escape Analysis:
10. Where objects are stored in Java
11. Hashtable HashMap LinkedHashMap TreeMap
11a. HashTable vs HashMap vs ConcurrentHashMap
11b. HashTable vs ConcurrentHashMap
11b. LinkedHashMap Complexity and Usage
12. How to make System.out.println() shorter
13. Using int vs Integer
13b. Using array vs ArrayList
14. How do I apply the for-each loop to every character in a String / Iterate over a String
15. Why can Java Collections not directly store Primitives types
16. Why is Java Vector class considered obsolete or deprecated
17. What is meant by immutable
18. Why is String immutable in Java
19. What does String Immutable mean
20. Combining charAt and IgnoreCasE
21. Adding Object to an ArrayList adds its reference
22. Java Constructors and Super Class
23. Exceptions
24. Final, Finally, Finalize
24b. Final in Java
25. How to find index of min element in a list
26. Get current date and time
27. Priority Queue peek, element, poll, remove
28. Priority Queue Offer vs Add
28b. Priority Queue Reverse Order:
29. for each loop in Java
30. Increment Value of a HashMap's Key
30a. HashMap get and delete if key is absent
30b. Print All Key Value pairs of Hashmap in Java
30c. Add to an arraylist in HashMap
30d. Sort HashMap by values
30d2. Custom comparator for PriorityQueue
30e. Comparator for TreeMap and TreeSet
30f. Hashmap getOrDefault
31. How to split a string in Java
32. Java String to Int and Int to String
33. Iterating over a Map using EntrySet
34. Signed Right Shift and Unsigned Right Shift
35. Method Variables and Class Variables with Final
36. Creating Java Objects
37. Why Java string does not need new to create
38. How are Java objects stored in memory
38b. When is memory allocated
39. Java Pass by value or Pass by reference
40. Check ArrayLists is empty
41. Check if Array is empty
42. Convert Array to ArrayList in Java
42a. How to convert int[] into List<Integer> in Java?
42b. Convert Array to Set
42c. Convert ArrayList to Array in Java
43. Integer MAX_VALUE
44. Char array to String
45. String to Char Array
46. Length Length() and Size()
47. How to use Iterator in Java
48. Generating Random Number
49. Using Synchronized in Java
49b. Java synchronized method lock on object, or method?
50. Converting int to Integer and Integer to int
51. Iterator for LinkedHashMap
52. What are Packages
53. What is CLASSPATH
54. What is Strongly Typed / Weak Typed, Static Typed and Dynamic Typed Language
55. C++ Features Missing in Java
56. Java Main Class need not be Public
57. What is Volatile in Java
58. Can't use INT as Bool in condition
59. >>> and >>
60. try catch throw throws finally throwable
61. What is finalize
62. Create 2D Array in Java
63. Access Specifiers in Java
64. Convert base2 string to decimal
64b. Convert decimal to binary, octal, hex
64c. Count number of bits in a number
65. Convert a char to an int or Get numeric value of a character
66. What is THIS
67. Java Heap Old gen, Perm Gen and Young gen
68. Declare array in Java
69. Boolean[] vs BitSet
70. ArrayList get set
71. Array and ArrayList pass reference by value
72. Change a character in a String
73. Java FileChannel - Java NIO
74. @Override
75. Get Boolean from a String
76. Try Catch Throws - Komprise
77. String concatenation for Logging {} vs +
78. Logging exception
79. How to fix Could not find or load main class error
80. Run class inside a jar, MVN Building app into JAR with all dependencies and running the app - Fat JAR
81. How to resolve Could not find or load main class Foo error
82. Print a list using forEach
83. How to convert Java String into byte[]?
83b. Convert integer into byte array (Java)
84. Is there an equivalent to memcpy() in Java?
85. Print an integer in binary format in Java
86. Converting Little Endian to Big Endian
87. StringBuilder vs String
88. How to read an unknown number of bytes from an inputStream (socket/socketServer)?
89. Receive byte[] using ByteArrayInputStream from a socket
90. How can I convert a 4-byte array to an integer?
91. Java ByteBuffer to String
92. How to convert a String into an ArrayList?
93. Default values to arguments in function
94. Static classes in Java
95. What is try-with-resources
96. Sort list of strings
96b. Sort array
97. Using enum
98. Collection.containsAll()
99. Add a list in a hashset using addAll
100. Convert list to a set
101. Comparing and removing elements not present in a List and array java
102. Convert List<String> to List<Integer> directly
103. Communication between java threads: stopping all threads when one finishes its task
104. Multithreading - Callable vs Runnable and Future
104b1. Multithreading - “implements Runnable” vs. “extends Thread”
104b2. Creating new Threads
104b3. Creating dynamic number of threads
104c. CountdownLatch
104d. Blocking queue and multi-threaded consumer, how to know when to stop
104e. Does notify/notifyall release the lock being held
104f. Sleep vs Wait Thread.sleep() does not release the lock. wait() releases the lock
105. Difference between Arrays.asList(array) vs new ArrayList<Integer>(Arrays.asList(ia)) in java
106. Can I compile a java file with a different name than the class?
107. Is main method compulsory in Java
108. Java Data structures:
109. Difference between int[] array and int array[]
110. How to fill an array with certain value (zero fill)
110b. How can I initialize an ArrayList with all zeroes in Java?
111. How do I declare and initialize an array in Java?
112. Setting initial capacity to array list
113. Java Streams
114. Static nested class in Java, why
114b. Java inner class and static nested class
115. ExecutorService Shutdown
116. Catch multiple exceptions
117. Concatenate strings using System.out.println
118. Create array of certain size such that it can't grow beyond that
119. How can I pass a parameter to a Java Thread
120. Java Blocking Queue
121. Default Methods In Java
122. Interface with default methods vs Abstract class in Java 8
123. Java Scanner vs BufferedReader
124. Scanner method to get a char
125. Scanner is skipping nextLine() after using next(), nextInt() or other nextFoo()?
126. Read array using Scanner and BufferedReader
127. Read multiple lines from console
128. STRING OPERATIONS
128a. Find index of String in another string
128b. Get substring from String / StringBuilder
128c. Java indexOf method for multiple matches in String
129. How can I clear or empty a StringBuilder?
130. What is the best way to tell if a character is a letter or number in Java without using regexes?
131. How to determine if a String has non-alphanumeric characters
132. Don't assign one list to another
133. How to sort Map values by key in Java
134. Arrays.fill with multidimensional array in Java
135. Implement Comparator function
136. Possible Lossy conversion from long to int
137. How do I convert from int to Long in Java?
138. Do containsAll() and retainAll() in the Collection interface address cardinality?
139. Simple way to find if two different lists contain exactly the same elements?
140. CompareTo with primitives -> Integer / int
141. Initialization of an ArrayList in one line
142. How to convert int[] into List<Integer> in Java?
143. How to set a default value for items list / array?
144. Get Size of data types
145. Remove last character from String and StringBuilder
146. Convert int to int array
147. Change char in a StringBuilder
148. String equals
149. String.charAt() goes out of bound if index is beyond string length
150. How to initialize HashSet values by construction?
151. List of lists
152. Directly return an array
153. Delete / Remove range of elements from a list
154. Int to Char and Char to int
155. Convert HashSet to List
156. String to Uppercase (Upper case) and lowercase (lower case)
157. Count number of digits in a number
157b. Log base2 in Java
158. Remove duplicate lists using Collection
159. Java Arrays how to add elements at the beginning
160. Create a compareTo to a Generic Class that Implements Comparable
161. Java- The meaning of <T extends Comparable<T>>?
162. Get first / last element from LinkedHashMap and LinkedHashSet
163. What's the difference between ConcurrentHashMap and Collections.synchronizedMap(Map)?
164. Java Fastest way to read through text file with 2 million lines
165. Find an array inside another larger array
166. File to byte[] in Java
167. How can the wait() and notify() methods be called on Objects that are not threads?
168. Multithreading - Counting total amount of words from several files
169. Deep, Shallow and Lazy Copy with Java Examples
170. How to merge more than one hashmaps also sum the values of same key in java
171. Access private method from outside the class
172. Java Queue LinkedList vs ArrayDeque
173. Remove element from Array
174. why is Stack a class while Queue is a Interface?
175. Call constructor from main AND initialize array in constructor with capacity
176. Java Options class
177. What is the difference between “Class.forName()” and “Class.forName().newInstance()”?
178. In Eclipse, can I have multiple Console views at once, each showing a different Console?
179. What is the difference between System.getProperty and properties.getProperty in Java
180. Using Java System Properties
181. Difference between System.getenv() & System.getProperty() [duplicate]
182. Finding enum value with Java 8 Stream API
183. Static Initialization Blocks
184. GROOVY:
185. JsonMappingException: No suitable constructor found for type [simple type, class ]: can not instantiate from JSON object
186. Why Objects should be immutable
187. How to create default constructor for immutable class
188. Using Executor Service and Thread
189. Making local variables and parameters as final
190. Mockito test a void method throws an exception
191. Test coverage to private constructor
192. Static import in Java
193. Java 8 Function
194. Java STREAMS
195. Get first element of HashSet
196. Iterate through HashSet
197. Java 8 stream operation on empty list
198. Java Platform Independent
--------------------------------------------------------------------------------

1.
Why Java uses Heap instead of Stack
http://stackoverflow.com/questions/15558245/why-does-java-use-heap-data-structure-to-store-object
http://stackoverflow.com/questions/3646632/do-java-primitives-go-on-the-stack-or-the-heap
https://stackoverflow.com/questions/23550385/where-are-instance-variables-of-an-object-stored-in-the-jvm

    Primitives defined locally would be on the stack. However if a primitive were defined as part of an instance of an object, that primitive would be on the heap.
        public class Test
        {
            private static class HeapClass
            {
                public int y; // When an instance of HeapClass is allocated, this will be on the heap.
            }
            public static void main(String[] args)
            {
                int x=1; // This is on the stack.
            }
        }

    With regards to the update:
        Objects do not have their own stack.
        In my example, int y would actually be part of each instance of HeapClass.
        Whenever an instance of HeapClass is allocated (e.g. new HeapClass()), all member variables of HeapClass are added to the heap.
        Thus, since instances of HeapClass are being allocated on the heap, int y would be on the heap as part of an instance of HeapClass.

    However, all primitive variables declared in the body of any method would be on the stack.

    As you can see in the above example, int x is on the stack because it is declared in a method body--not as a member of a class.

    Stack and heap are the memories allocated by the OS to the JVM that runs in the system.Stack is a memory place where the methods and the local variables are stored. (variable references either primitive or object references are also stored in the stack). Heap is a memory place where the objects and its instance variable are stored.

    So to sum it up:
        Class objects, including method code and static fields: heap.
        Objects, including instance fields: heap.
        Local variables and calls to methods: stack

2.
Access Specifiers
    a. Public:    Everyone
    b. Private:   Only that class
    c. Protected: Inheriting Class
    d. Default  : Class in the same package

3.
Early Binding
    In Java, late binding is the default behavior

4. 
Object Base Class
    All objects are inherited from Object Base Class

5.
What are Generics in Java
http://docs.oracle.com/javase/tutorial/java/generics/erasure.html
http://stackoverflow.com/questions/490091/java-generics

    - A type of container

    Type Erasure
    Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming.
    To implement generics, the Java compiler applies type erasure to:

        Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.
        Insert type casts if necessary to preserve type safety.
        Generate bridge methods to preserve polymorphism in extended generic types.

    Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.

    Vectors hold any old object you give them.
        V.add("This is an element");
        V.add(new Integer(2));
        v.add(new Hashtable());

    To get back the item
        String s = (String) v.get(0);
        Integer i = (Integer) v.get(1);
        Hashtable h = (Hashtable) v.get(2);
    
    Generics attempt to create strongly typed classes to do generic operations.
        ArrayList<String> aList = new ArrayList<String>();
        aList.add("One");
        String element = aList.get(0); // no cast needed
        System.out.println("Got one: " + element);

http://www.tutorialspoint.com/java/java_generics.htm
        public class GenericMethodTest
        {
           // generic method printArray                         
           public static < E > void printArray( E[] inputArray )
           {
              // Display array elements              
                 for ( E element : inputArray ){        
                    System.out.printf( "%s ", element );
                 }
                 System.out.println();
            }

            public static void main( String args[] )
            {
                // Create arrays of Integer, Double and Character
                Integer[] intArray = { 1, 2, 3, 4, 5 };
                Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
                Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

                System.out.println( "Array integerArray contains:" );
                printArray( intArray  ); // pass an Integer array

                System.out.println( "\nArray doubleArray contains:" );
                printArray( doubleArray ); // pass a Double array

                System.out.println( "\nArray characterArray contains:" );
                printArray( charArray ); // pass a Character array
            } 
        }

6. 
Heap and Stack Storage
    - Objects are stored on Heap
    - Primitive types are stored on Stack

7.
How Garbage Collector Works
http://stackoverflow.com/questions/774357/how-does-the-garbage-collection-mechanism-work
https://www.geeksforgeeks.org/garbage-collection-java/
https://www.geeksforgeeks.org/how-to-make-object-eligible-for-garbage-collection/
https://www.geeksforgeeks.org/island-of-isolation-in-java/

    - The way actual memory gets allocated to variables and the way it is reclaimed is abstracted from the programmer.
    - The acutal where the memory gets allocated is abstracted

    - When the GARBAGE COLLECTOR runs it will check if we still hold a reference to an object. If not it will free that memory.

    SIMPLEST:
        Reference counting:
            - Whenever an object gets referenced, a count is incremented
            - GARBAGE Collector moves through ALL THE OBJECTS and frees the ones that has ref count as ZERO
            PROBLEM:
            - Circular reference
			class Pointy {
				public Pointy other;
			}

			Pointy one = new Pointy();
			Pointy two = new Pointy();
			one.other = two;
			two.other = one;

    MARK and SWEEP
        The mark and sweep algorithm works by periodically stopping the execution of the program, mark each item the program has allocated as unreachable.
        The program then runs through all the variables the program has and marks what they point to as reachable.
        If either of these allocations contain references to other data in the program, that data is then likewise marked as reachable, etc.

        This is the mark part of the algorithm.
        At this point everything the program can access, no matter how indirectly, is marked as reachable and everything the program can't reach is marked as unreachable.
        The garbage collector can now safely reclaim the memory associated with the objects marked as unreachable.

        SWEEP: takes care of freeing all objexts that are not reachable

        PROBLEM:
            - Entire Program has to be stopped

    ADAPTIVE GARBAGE COLLECTION:
        - START @ RAM's static and stack portion and go through all the OBJECTS
        - Copy all live objects to ANOTHER HEAP. 
        - Remove the objects from original heap

        PROBLEM:
            - Twice the memory

        SOLUTION:
            - Once program is stable, don't have to KEEP copying as LITTLE or NO GARBAGE would be generated.
            - JVM detects this and switch to M&S

FROM GEEKSFORGEEKS:
        An object is eligible to be garbage collected if its reference variable is lost from the program during execution.Sometimes they are also called unreachable objects.

        What is reference of an object?

        The new operator dynamically allocates memory for an object and returns a reference to it. This reference is the address in memory of the object allocated by new. A reference is an address that indicates where an object’s variables, methods etc. are stored.

        The objects are not actually used when assigned to a variable or passed as an argument to a method . The references to objects are used everywhere. Example:

        Box mybox =  new Box();   //referencing to object

        Role of an unreachable objects in java

        In java, the memory allocated at runtime i.e. heap area can be made free by the process of garbage collection. It is nothing but just a method of making the memory free which is not being used by the programmer. Only the objects who have no longer reference to them are eligible for garbage collection in java.

        Ways to make an object eligible for garbage collection:

        Please note that the object can not become a candidate for garbage collection until all references to it are discarded.

            Object created inside a method : When a method is called it goes inside the stack frame. When the method is popped from the stack, all its members dies and if some objects were created inside it then these objects becomes unreachable or anonymous after method execution and thus becomes eligible for garbage collection
            .Example:

            /* Java program to demonstrate that 
            objects created inside a method will becomes
            eligible for gc after method execution terminate */
             
            class Test
            {
                 
                // to store object name
                String obj_name;
                 
                public Test(String obj_name) 
                {
                    this.obj_name = obj_name;
                }
                 
                static void show()
                {
                    //object t1 inside method becomes unreachable when show() removed
                    Test t1 = new Test("t1"); 
                    display();
                     
                }
                static void display()
                {
                    //object t2 inside method becomes unreachable when display() removed
                    Test t2 = new Test("t2"); 
                }
                 
                // Driver method
                public static void main(String args[])
                {
                    // calling show()
                    show();
                     
                    // calling garbage collector
                    System.gc();
                }
                 
                @Override
                /* Overriding finalize method to check which object
                is garbage collected */
                protected void finalize() throws Throwable 
                {
                    // will print name of object
                    System.out.println(this.obj_name + " successfully garbage collected");
                }
            }

        Output:

        t1 successfully garbage collected
        t2 successfully garbage collected

        Note : If a method returns the object created inside it and we store this object reference by using a reference-type variable than it is no longer eligible for garbage collection.
        Reassigning the reference variable: When reference id of one object is referenced to reference id of some other object then the previous object has no any longer reference to it and becomes unreachable and thus becomes eligible for garbage collection.Example:
        /* Java program to demonstrate gc
         when one object referred to other object */
         
        class Test
        {
            // to store object name
            String obj_name;
             
            public Test(String obj_name) 
            {
                this.obj_name = obj_name;
            }
             
            // Driver method
            public static void main(String args[])
            {
                Test t1 = new Test("t1");
                Test t2 = new Test("t2");
                 
                //t1 now referred to t2
                t1 = t2;
                 
                // calling garbage collector
                System.gc();
            }
             
            @Override
            /* Overriding finalize method to check which object
             is garbage collected */
            protected void finalize() throws Throwable 
            {
                // will print name of object
                System.out.println(this.obj_name + " successfully garbage collected");
            }
        }

        Output:

        t1 successfully garbage collected

        Nullifying the reference variable : When all the reference variables of an object are changed to NULL, it becomes unreachable and thus becomes eligible for garbage collection.Example:
        /* Java program to demonstrate gc
         when object reference changed to NULL */
         
        class Test
        {
            // to store object name
            String obj_name;
             
            public Test(String obj_name) 
            {
                this.obj_name = obj_name;
            }
             
            // Driver method
            public static void main(String args[])
            {
                Test t1 = new Test("t1");
                  
                /* t1 being used for some purpose in program */
          
                /* When there is no more use of t1, make the object
                   referred by t1 eligible for garbage collection */       
                t1 = null;
          
                // calling garbage collector
                System.gc();
            }
             
            @Override
            /* Overriding finalize method to check which object
             is garbage collected */
            protected void finalize() throws Throwable 
            {
                // will print name of object
                System.out.println(this.obj_name + " successfully garbage collected");
            }
        }

        Output:

        t1 successfully garbage collected

        Anonymous object : The reference id of an anonymous object is not stored anywhere. Hence, it becomes unreachable.
        Example:

        /* Java program to demonstrate gc
         of anonymous objects */
         
        class Test
        {
            // to store object name
            String obj_name;
             
            public Test(String obj_name) 
            {
                this.obj_name = obj_name;
            }
             
            // Driver method
            public static void main(String args[])
            {
                //anonymous object without reference id
                new Test("t1"); 
          
                // calling garbage collector
                System.gc();
            }
             
            @Override
            /* Overriding finalize method to check which object
             is garbage collected */
            protected void finalize() throws Throwable 
            {
                // will print name of object
                System.out.println(this.obj_name + " successfully garbage collected");
            }
        }

        Output:

        t1 successfully garbage collected

https://www.geeksforgeeks.org/island-of-isolation-in-java/
        In java, object destruction is taken care by the Garbage Collector module and the objects which do not have any references to them are eligible for garbage collection. Garbage Collector is capable to identify this type of objects.
        Island of Isolation:

            Object 1 references Object 2 and Object 2 references Object 1. Neither Object 1 nor Object 2 is referenced by any other object. That’s an island of isolation.
            Basically, an island of isolation is a group of objects that reference each other but they are not referenced by any active object in the application. Strictly speaking, even a single unreferenced object is an island of isolation too.

        Example:
        public class Test
        {
            Test i;
            public static void main(String[] args)  
            {
                Test t1 = new Test();
                Test t2 = new Test();
                  
                // Object of t1 gets a copy of t2
                t1.i = t2;
              
                // Object of t2 gets a copy of t1
                t2.i = t1;
                  
                // Till now no object eligible
                // for garbage collection 
                t1 = null;
                 
                //now two objects are eligible for
                // garbage collection 
                t2 = null;
                 
                // calling garbage collector
                System.gc();
                
            }
         
            @Override
            protected void finalize() throws Throwable 
            { 
                System.out.println("Finalize method called"); 
            }
        }

        Output:

        Finalize method called
        Finalize method called

        Explanation :
        Before destructing an object, Garbage Collector calls finalize method at most one time on that object.
        The reason finalize method called two times in above example because two objects are eligible for garbage collection.This is because we don’t have any external references to t1 and t2 objects after executing t2=null.
        All we have is only internal references(which is in instance variable i of class Test) to them of each other. There is no way we can call instance variable of both objects. So, none of the objects can be called again.

8.
How JVM works
https://www.youtube.com/watch?v=viS5d8DA_VI
https://www.geeksforgeeks.org/jvm-works-jvm-architecture/

    a1.c ---              a1.obj
            |
            |
    a2.c ---> COMPILER -- a2.obj ---> LINKER --> a.exe
            |
            |
    a3.c ---              a3.obj

    LOADER puts a.exe into Main Memory

    IN JAVA:
        - .class FILE CONTAINS the BYTECODE
        - NO LINKING IS DONE
        - JVM RESIDES on RAM

        a1.java                 a1.class

        a2.java ---> COMPILER ->a2.class

        a3.java                 a3.class

        - CLASS LOADER puts all the CLASS files ONTO RAM
        - BYTECODE Verifier verfies the Byte Code
            - Checks for ACCESS VIOLATION errors etc
        - EXECUTION ENGINE
            - USE JIT COMPILER and converts BYTE CODE into MACHINE CODE

9.
What is Escape Analysis:
http://programmers.stackexchange.com/questions/65281/stack-and-heap-memory-in-java
    - Escape analysis determines all the places where a pointer can be stored and whether the lifetime of the pointer can be proven to be restricted only to the current procedure and/or thread.
    - JVMs can use a technique called escape analysis, by which they can tell that certain objects remain confined to a single thread for their entire lifetime, and that lifetime is bounded by the lifetime of a given stack frame.
    - Such objects can be safely allocated on the stack instead of the heap.
    - Even better, for small objects, the JVM can optimize away the allocation entirely and simply hoist the object's fields into registers.
    
    Thus, if you have code that looks like:

        void foo(int arg) {
            Bar qux = new Bar(arg);
            ...
        }

    where the ... doesn't allow qux to leave that scope, qux may be allocated on the stack instead.
    This is actually a win for the VM because it means it doesn't need to ever be garbage collected - it will disappear when it leaves the scope

10.
Where objects are stored in Java
http://programmers.stackexchange.com/questions/65281/stack-and-heap-memory-in-java
http://stackoverflow.com/questions/3646632/do-java-primitives-go-on-the-stack-or-the-heap

    - Java only stores primitives on the stack.
    - Objects are created on the heap

    - Only REFERENCES (which in turn are primitives) are passed around on the stack.

    - An OBJECT with all its variables are PUT on HEAP

    class A {
       int a ;
       String b;
       //getters and setters
    }

    - Where will the primitive a in class A be stored?
        - Depends on Escape analysis and JVM

    - Why does heap memory exist at all? Why can't we store everything on the stack?
        - Then we would have to pass the full set of values from one function to another.
        - With heap only a reference to it is required.
        - You could have a huge string that occupies the entire stack memory

    - Why Stack memory exists ?
        - Compilers can have stuffs without a stack
        - Eg BASICS which just had 8 registers
        - STACK gets rid of MEMORY FRAGMENTATION
        - Advantage of SCOPE. On leaving the SCOPE the stack is popped.

    Primitives defined locally would be on the stack. However if a primitive were defined as part of an instance of an object, that primitive would be on the heap.

        public class Test
        {
            private static class HeapClass
            {
                public int y; // When an instance of HeapClass is allocated, this will be on the heap.
            }
            public static void main(String[] args)
            {
                int x=1; // This is on the stack.
            }
        }

    Objects do not have their own stack.
    In my example, int y would actually be part of each instance of HeapClass.
    Whenever an instance of HeapClass is allocated (e.g. new HeapClass()), all member variables of HeapClass are added to the heap.
    Thus, since instances of HeapClass are being allocated on the heap, int y would be on the heap as part of an instance of HeapClass.

    However, all primitive variables declared in the body of any method would be on the stack.

    As you can see in the above example, int x is on the stack because it is declared in a method body--not as a member of a class.

11.
Hashtable HashMap LinkedHashMap TreeMap
http://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/

    There are 4 commonly used implementations of Map in Java SE - HashMap, TreeMap, Hashtable and LinkedHashMap.
    If we use only one sentence to describe each implementation, it would be the following:

        HashMap is implemented as a hash table, and there is no ordering on keys or values.
        TreeMap is implemented based on red-black tree structure, and it is ordered by the key.
        LinkedHashMap preserves the insertion order
        Hashtable is synchronized, in contrast to HashMap. It has an overhead for synchronization.

        This is the reason that HashMap should be used if the program is thread-safe

11a.
HashTable vs HashMap vs ConcurrentHashMap
https://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable

IMP:
    Naive approach to thread-safety in Hashtable makes it very much worse for threaded applications.
    You're better off externally synchronizing a HashMap, or using a ConcurrentMap implementation.
    Bottom line: the only reason to use Hashtable is when a legacy API (from ca. 1996) requires it

    - Hashtable is synchronized, whereas HashMap is not.
    - Hashtable does not allow null keys or values.  HashMap allows one null key and any number of null values
    - One of HashMap's subclasses is LinkedHashMap, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you were using Hashtable

11b. HashTable vs ConcurrentHashMap
https://stackoverflow.com/questions/12646404/concurrenthashmap-and-hashtable-in-java
    ConcurrentHashMap uses multiple buckets to store data. This avoids read locks and greatly improves performance over a HashTable. Both are thread safe, but there are obvious performance wins with ConcurrentHashMap.

    When you read from a ConcurrentHashMap using get(), there are no locks, contrary to the HashTable for which all operations are simply synchronized.

11b.
LinkedHashMap Complexity and Usage

    If LinkedHashMap's time complexity is same as HashMap's complexity why do we need HashMap?

    You should not confuse complexity with performance. Two algorithms can have the same complexity, yet one can consistently perform better than the other.

    Remember that f(N) is O(N) means that:

    C1*N <= limit(f(N), N -> infinity) <= C2*N  

    where C1 and C2 are strictly positive constants. The complexity says nothing about how small or large the C values are. For two different algorithms, the constants will most likely be different.

    (And remember that big-O complexity is about the behavior / performance as N gets very large. It tells you nothing about the behavior / performance for small N values.)

12.
How to make System.out.println() shorter
http://stackoverflow.com/questions/3320764/how-to-make-system-out-println-shorter

    void println(Object line) {
        System.out.println(line);
    }

    println("Hello World");

13.
Using int vs Integer
http://stackoverflow.com/questions/564/what-is-the-difference-between-an-int-and-an-integer-in-java-and-c?rq=1

    If you can use int do so.
    If the value can be null or is used as an Object e.g. Generics, use Integer

    In Java an int is a primitive while an Integer is an Object. Meaning, if you made a new Integer:
        Integer i = new Integer(6);

    You could call some method on i:
        String s = i.toString();//sets s the string representation of i

    Whereas with an int:
        int i = 6;

    You cannot call any methods on it, because it is simply a primitive. So:
        String s = i.toString();//will not work!!!

    // IMP: Can't use "=="
        Integer alpha = new Integer(1);
        Integer foo = new Integer(1);

        if(alpha == foo) {
            System.out.println("1. true");
        }

        if(alpha.equals(foo)) {
            System.out.println("2. true");
        }

13b.
Using array vs ArrayList
http://stackoverflow.com/questions/2843928/benefits-of-arrays

    Arrays are better in the following situations:
        you know that you will work with fixed number of elements in the array
        you don't need to change size of the array
    Arrays are:
        faster than any Collection

    Arrays are more efficient, both in terms of processing time and memory footprint. This particularly applies if you are operating on primitive types, such as int or long, since List requires all elements to be wrapped in an Object (such as Integer or Long). While the autoboxing features introduced by Java 5 reduces the amount of code you need for such wrapping and unwrapping, it does not remove the performance issues, as wrapper objects are still being created.

    However, most applications probably do not have any performance bottlenecks related to these issues, so in most cases, List and other collections should do fine. In these cases, the ease of programming outweighs the increase in memory or CPU usage, and List is the right choice.

    One thing I have not seen mentioned here: arrays can have N dimensions whereas lists are limited to one. You can use lists of lists but the syntax (List<List<...>>) is much more cumbersome than [][]

    there is one subtle property of arrays that can be considered an advantage over lists. It can be illustrated by the following code:

    //This works
    Integer[] ints = new Integer[4];
    Number[] nums = ints;
    //This doesn't work
    List<Integer> intList = new ArrayList<Integer>();
    List<Number> numList = intList; //Does not compile
    List<Number> numList2 = (List<Number>)intList; //Does not compile either
    While an array of a subclass IS an array of the superclass, lists of subclasses are NOT lists of superclasses (and there is a good reason for it - generics would have a type safery flaw if it were allowed).

14.
How do I apply the for-each loop to every character in a String / Iterate over a String
http://stackoverflow.com/questions/2451650/how-do-i-apply-the-for-each-loop-to-every-character-in-a-string

    for (char ch: "xyz".toCharArray()) {
    }

    String s = "xyz";
    for(int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
    }

15.
Why can Java Collections not directly store Primitives types
http://stackoverflow.com/questions/2504959/why-can-java-collections-not-directly-store-primitives-types

    It was a Java design decision, and one that some consider a mistake.
    Containers want Objects and primitives don't derive from Object.

16.
Why is Java Vector class considered obsolete or deprecated
http://stackoverflow.com/questions/1386275/why-is-java-vector-class-considered-obsolete-or-deprecated

    Vector synchronizes on each individual operation.
    That's almost never what you want to do.

    Generally you want to synchronize a whole sequence of operations.
    Synchronizing individual operations is both less safe (if you iterate over a Vector, for instance, you still need to take out a lock to avoid anyone else changing the collection at the same time, which would cause a ConcurrentModificationException in the iterating thread) but also slower (why take out a lock repeatedly when once will be enough)?

    Of course, it also has the overhead of locking even when you don't need to.

    Basically, it's a very flawed approach to synchronization in most situations.

17.
What is meant by immutable
http://stackoverflow.com/questions/279507/what-is-meant-by-immutable

    Immutable means that once the constructor for an object has completed execution that instance can't be altered.

    This is useful as it means you can pass references to the object around, without worrying that someone else is going to change its contents.
    Especially when dealing with concurrency, there are no locking issues with objects that never change

    e.g.
    class Foo
    {
         private final String myvar;

         public Foo(final String initialValue)
         {
             this.myvar = initialValue;
         }

         public String getValue()
         {
             return this.myvar;
         }
    }

    Foo doesn't have to worry that the caller to getValue() might change the text in the string.

    If you imagine a similar class to Foo, but with a StringBuilder rather than a String as a member, you can see that a caller to getValue() would be able to alter the StringBuilder attribute of a Foo instance.

18.
Why is String immutable in Java
http://stackoverflow.com/questions/22397861/why-is-string-immutable-in-java
http://stackoverflow.com/questions/1552301/immutability-of-strings-in-java

    String is immutable for several reasons, here is a summary:

        Security: parameters are typically represented as String in network connections, database connection urls, usernames/passwords etc.
                  If it were mutable, these parameters could be easily changed.
        Synchronization and concurrency: making String immutable automatically makes them thread safe thereby solving the synchronization issues.
        Caching: When compiler optimizes your String objects, it sees that if two objects have same value (a="test", and b="test") and thus you need only one string object (for both a and b, these two will point to the same object).
        Class loading: String is used as arguments for class loading. If mutable, it could result in wrong class being loaded (because mutable objects change their state).

    That being said, immutability of String only means you cannot change it using its public API. You can in fact bypass the normal API using reflection. See the answer here.

    In your example, if String was mutable, then consider the following example:

      String a="stack";
      System.out.println(a);//prints stack
      a.setValue("overflow");
      System.out.println(a);//if mutable it would print overflow

19.
What does String Immutable mean
http://stackoverflow.com/questions/8798403/string-is-immutable-what-exactly-is-the-meaning

    Before proceeding further with the fuss of immutability, let's just take a look into the String class and its functionality a little before coming to conclusions about its immutability.

    This is how String works:
        String str = "knowledge";

    This, as usual, creates a string containing "knowledge" and assigns it a reference str.
    Simple enough? Lets perform some more functions:
         String s = str;     // assigns a new reference to the same string "knowledge"

    Lets see how the below statement works:
         str = str.concat(" base");

    This appends a string " base" to str. But wait, how is this possible, since String objects are immutable? Well to your surprise, it is.

    When the above statement is executed, the VM takes the value of String str, i.e. "knowledge" and appends " base", giving us the value "knowledge base".
    Now, since Strings are immutable, the VM can't assign this value to str, so it creates a new String object, gives it a value "knowledge base", and gives it a reference str.

    An important point to note here is that, while the String object is immutable, its reference variable is not.
    So that's why, in the above example, the reference was made to refer to a newly formed String object.

    At this point in the example above, we have two String objects: the first one we created with value "knowledge", pointed to by s, and the second one "knowledge base", pointed to by str.
    But, technically, we have three String objects, the third one being the literal "base" in the concat statement.

    IMPORTANT FACTS ABOUT STRING AND MEMORY USAGE:
        What if we didn't have another reference s to "knowledge"? We would have lost that String.
        However, it still would have existed, but would be considered lost due to having no references.
        Look at one more example below

            String s1 = "java";
            s1.concat(" rules");
            System.out.println("s1 refers to "+s1);  // Yes, s1 still refers to "java"

    What's happening:
        The first line is pretty straightforward: create a new String "java" and refer s1 to it.
        Next, the VM creates another new String "java rules", but nothing refers to it.
        So, the second String is instantly lost. We can't reach it.

    The reference variable s1 still refers to the original String "java".

    Almost every method, applied to a String object in order to modify it, creates new String object.
    So, where do these String objects go? Well, these exist in memory, and one of the key goals of any programming language is to make efficient use of memory.

    As applications grow, it's very common for String literals to occupy large area of memory, which can even cause redundancy.
    So, in order to make Java more efficient, the JVM sets aside a special area of memory called the "String constant pool".

    When the compiler sees a String literal, it looks for the String in the pool.
    If a match is found, the reference to the new literal is directed to the existing String and no new String object is created.
    The existing String simply has one more reference.
    Here comes the point of making String objects immutable:

    In the String constant pool, a String object is likely to have one or many references.
    If several references point to same String without even knowing it, it would be bad if one of the references modified that String value.
    That's why String objects are immutable.

    Well, now you could say, what if someone overrides the functionality of String class?
    That's the reason that the String class is marked final so that nobody can override the behavior of its methods.

20.
Combining charAt and IgnoreCasE
http://stackoverflow.com/questions/28387134/combining-charat-and-ignorecase

    (Character.toLowerCase(newGame.charAt(0)) == 'y');

21.
Adding Object to an ArrayList adds its reference
http://stackoverflow.com/questions/7080546/add-an-object-to-an-arraylist-and-modify-it-later
    
    Q. 
    If I have an ArrayList, and I added an object to it, and later I modified this object, will this change reflect in the ArrayList?
    Or when I add the object to the ArrayList, Java creates a copy and add it to the ArrayList?

    What if I change the reference to this object to null?
    Does that mean that the object in the ArrayList now null too?

    Q: will this change reflect in the ArrayList?
    A: Yes, since you added a reference to the object in the list. The reference you added will still point to the same object, (which you modified).

    Q: or when I add the object to the ArrayList, Java creates a copy and add it to the ArrayList?
    A: No, it won't copy the object. (It will copy the reference to the object.)

    Q: What if I change the reference to this object to null? Does that mean that the object in the ArrayList now null too?
    A: No, since the content of the original reference was copied when added to the list. (Keep in mind that it is the reference that is copied, not the object.)

        Demonstration:
        StringBuffer sb = new StringBuffer("foo");

        List<StringBuffer> list = new ArrayList<StringBuffer>();
        list.add(sb);

        System.out.println(list);   // prints [foo]
        sb.append("bar");

        System.out.println(list);   // prints [foobar]
        sb = null;

        System.out.println(list);   // still prints [foobar]

22.
Java Constructors and Super Class
http://stackoverflow.com/questions/3767365/super-in-java 

    1. If the FIRST LINE of the constructor is NOT a call to Super Class Constructor OR a call
    to ONE of its own constructor THEN the compiler will insert "super()" as the first line in
    the constructor

    2. Java WILL NOT insert a "super()" constructor if we already have one with arguments

    3. Always have a constructor with NO ARGUMENTS as java could add a "super()" and try to call
       a constructor with NO arguments.

    Calling exactly super() is always redundant.
    It's explicitly doing what would be implicitly done otherwise.
    That's because if you omit a call to the super constructor, the no-argument super constructor will be invoked automatically anyway.
    Not to say that it's bad style; some people like being explicit.

    However, where it becomes useful is when the super constructor takes arguments that you want to pass in from the subclass.

        public class Animal {
           private final String noise;
           protected Animal(String noise) {
              this.noise = noise;
           }

           public void makeNoise() {
              System.out.println(noise);
           }
        }

        public class Pig extends Animal {
            public Pig() {
               super("Oink");
            }
        }

23.
Exceptions
    - If a client can reasonably be expected to recover from an exception, make it a checked exception.
    - If a client cannot do anything to recover from the exception, make it an unchecked exception

    Checked Exception vs Unchecked Exception:
        - Checked Exception should be DECLARED in the method

        - Common exception such as NULL pointer exceptions are Unchecked exceptions

    UNCHECKED:
        - Unchecked are the exceptions that are not checked at compiled time.
        - In C++, all exceptions are unchecked, so it is not forced by the compiler to either handle or specify the exception.

24.
Final, Finally, Finalize
http://stackoverflow.com/questions/7814688/in-java-what-purpose-do-the-keywords-final-finally-and-finalize-fulfil

    1. final
        - final can be used to mark a variable "unchangeable"
            private final String name = "foo";  //the reference name can never change

        - final can also make a method not "overrideable"
            public final String toString() {  return "NULL"; }

        - final can also make a class not "inheritable". i.e. the class can not be subclassed
            public final class finalClass {...}
            public class classNotAllowed extends finalClass {...} // Not allowed

    2. finally
        - finally is used in a try/catch statement to execute code "always"
            lock.lock();
            try {
              //do stuff
            } catch (SomeException se) {
              //handle se
            } finally {
              lock.unlock(); //always executed, even if Exception or Error or se
            }

        Java 7 has a new try with resources statement that you can use to automatically close resources that explicitly or implicitly implement java.io.Closeable or java.lang.AutoCloseable

    3. finalize
        finalize is called when an object is garbage collected. You rarely need to override it.
        An example:
            protected void finalize() {
              //free resources (e.g. unallocate memory)
              super.finalize();
            }

24b.
Final in Java
http://stackoverflow.com/questions/15655012/how-final-keyword-works
Thinking in Java
    
    Why Final?
        - To create a constant
        1. Compile Time Constant:
            - Value Won't ever change
            - Calculations using compile time constants can be performed at compile time
            - This eliminates runtime overhead

            - Use "final" on primitive data types to create compile time constants
            - Also a value MUST be given at compile time

            IMP: 
              final int a;
              Error will be thrown only when trying to access the variable

        2. Run time constant:
            - Value gets initialized at run time

            - Using "final" on Object References makes the REFERENCE a constant
            - Once the reference is initialized to an object, it can never be changed to
              point to another object.
            - But the object itself can be modified

25.
How to find index of min element in a list
http://stackoverflow.com/questions/15995458/how-to-find-the-minimum-value-in-an-arraylist-along-with-the-index-number-jav

    int minIndex = list.indexOf(Collections.min(list));

26.
Get current date and time
http://stackoverflow.com/questions/833768/java-code-for-getting-current-time

    new java.util.Date() : Human Readable Format
    System.currentTimeMillis() : 1478422910095

27.
Priority Queue peek, element, poll, remove
http://www.davismol.net/2014/04/04/java-ocpjp7-difference-between-element-peek-poll-and-remove-methods-of-the-queue-interface/

    The peek() method retrieves the value of the first element of the queue without removing it from the queue.
    For each invocation of the method we always get the same value and its execution does not affect the size of the queue. If the queue is empty the peek() method returns null.

    The element() method behaves like peek(), so it again retrieves the value of the first element without removing it. Unlike peek ), however, if the list is empty element() throws a NoSuchElementException

    The poll() method retrieves the value of the first element of the queue by removing it from the queue.
    At each invocation it removes the first element of the list and if the list is already empty it returns null but does not throw any exception

    The remove() method behaves as the poll() method, so it removes the first element of the list and if the list is empty it throws a NoSuchElementException

28.
Priority Queue Offer vs Add
http://stackoverflow.com/questions/2703984/what-is-the-difference-between-the-add-and-offer-methods-in-a-queue-in-java

    The Queue interface specifies that add() will throw an IllegalStateException if no space is currently available (and otherwise return true) while offer() will return false if the element couldn't be inserted due to capacity restrictions.

28b. Priority Queue Reverse Order:
https://stackoverflow.com/questions/11003155/change-priorityqueue-to-max-priorityqueue

    Java 8:
    PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());

    PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);

	PriorityQueue<Integer> pq = new PriorityQueue<Integer>(defaultSize, new Comparator<Integer>() {
    int compare(Integer lhs, Integer rhs) {
        if (lhs > rhs) return +1;
        if (lhs.equals(rhs)) return 0;
        return -1;
    }
});

29.
for each loop in Java

    for (int intValue : test) {
        // do some work here on intValue
    }

30.
Increment Value of a HashMap's Key
http://stackoverflow.com/questions/4157972/how-to-update-a-value-given-a-key-in-a-java-hashmap

    - map.put(key, map.get(key) + 1);
    - Replace Integer by AtomicInteger and call one of the incrementAndGet/getAndIncrement methods on it.
    - An alternative is to wrap an int in your own MutableInteger class which has an increment()

30a. HashMap get and delete if key is absent
    hashMap.remove(key):
        RETURNS: The previous value associated with key,
                 null if there was no mapping for key.
                 A null return can also indicate that the map previously associated null with key

    hashMap.get(key):
        A return value of null does not necessarily indicate that the map contains no mapping for the key;
        it's also possible that the map explicitly maps the key to null.
        The containsKey operation may be used to distinguish these two cases.

30b.
Print All Key Valye pairs of Hashmap in Java

    map.put("A", 1);
    map.put("B", 2);
    map.put("C", 3);

    for (String key : map.keySet()) {
        System.out.println(key + " " + map.get(key));
    }

    for (Map.Entry<KeyType, ValueType> entry : map.entrySet()) {
        System.out.println(entry.getKey()+" : "+entry.getValue());
    }

30c. Add to an arraylist in HashMap
https://stackoverflow.com/questions/12134687/how-to-add-element-into-arraylist-in-hashmap
    map.get(key).add(value)

30d. Sort HashMap by values
https://stackoverflow.com/questions/109383/sort-a-mapkey-value-by-values-java
    public static <K, V extends Comparable<? super V>> Map<K, V> 
        sortByValue(Map<K, V> map) {
        List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());
        Collections.sort( list, new Comparator<Map.Entry<K, V>>() {
            public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
                return (o1.getValue()).compareTo( o2.getValue() );
            }
        });

        Map<K, V> result = new LinkedHashMap<K, V>();
        for (Map.Entry<K, V> entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }
        return result;
    }

30d2. Custom comparator for PriorityQueue
        PriorityQueue<Pair<Integer, Pair<Integer, Integer>>> pqNums = new PriorityQueue<>(lists.size(), new Comparator<Pair<Integer, Pair<Integer, Integer>>>() {
            public int compare(Pair<Integer, Pair<Integer, Integer>> p1, Pair<Integer, Pair<Integer, Integer>> p2) {
                //return p1.getLeft() > p2.getLeft() ? 1 : p1.getLeft() < p2.getLeft() ? -1 : 0;
                return p1.getLeft().compareTo(p2.getLeft());
            }
        });


30e. Comparator for TreeMap and TreeSet
    SortedMap<String, Double> myMap = 
        new TreeMap<String, Double>(new Comparator<String>()
        {
            public int compare(String o1, String o2)
            {
                return o1.compareTo(o2);
            } 
    });

30f. Hashmap getOrDefault
        The below code can be replaced with
            if (charMap.containsKey(c)) {
                charMap.put(c, charMap.get(c) + 1);
            } else {
                charMap.put(c, 1);
            }

        This one
            charMap.put(c, charMap.getOrDefault(c, 0) + 1);

        Another way:
                Integer count = map.get(i);
                map.put(i, count != null ? count+1 : 0);

31.
How to split a string in Java
http://stackoverflow.com/questions/3481828/how-to-split-a-string-in-java

        String string = "004-034556";
        String[] parts = string.split("-");
        String part1 = parts[0]; // 004
        String part2 = parts[1]; // 034556

        String[] splited = str.split("\\s+");
    This will cause any number of consecutive spaces to split your string into tokens.

    Note that this takes a regular expression, so remember to escape special characters if necessary.
    There are 12 characters with special meanings: the backslash \, the caret ^, the dollar sign $, the period or dot ., the vertical bar or pipe symbol |, the question mark ?, the asterisk or star *, the plus sign +, the opening parenthesis (, the closing parenthesis ), and the opening square bracket [, the opening curly brace {, These special characters are often called "metacharacters".

    So, if you want to split on e.g. period/dot . which means "any character" in regex, use either backslash \ to escape the individual special character like so split("\\."), or use character class [] to represent literal character(s) like so split("[.]"), or use Pattern#quote() to escape the entire string like so split(Pattern.quote(".")).

        String[] parts = string.split(Pattern.quote(".")); // Split on period.

    ",\\s*" - comma followed by any whitespace

    https://books.google.com/books?id=diqHjRjMhW0C&pg=PA24&lpg=PA24&dq=java+string+split+%22,%5C%5Cs*%22&source=bl&ots=IwpwyEfgmz&sig=n0PZCuhVxDx5pwgEZI1D_YpTXrE&hl=en&sa=X&ved=0ahUKEwi5g76FuOHRAhVO3WMKHVd7C_UQ6AEISTAI#v=onepage&q=java%20string%20split%20%22%2C%5C%5Cs*%22&f=false
    \s - Whitespace (space, tab, line feed, carriage return)
    \S - Non Whitespace
    \d - Digits
    \D - Non Digits
    \w - 0-9,a-z,A-Z,_
    \W - Non word chars
    *  - Repeat preceding pattern 0 or more times
    +  - Repeat preceding pattern 1 or more times
    ?  - Repeat preceding pattern 0 or 1 times
32. 
Java String to Int and Int to String
http://stackoverflow.com/questions/5585779/converting-string-to-int-in-java
http://stackoverflow.com/questions/3335737/integer-tostringint-i-vs-string-valueofint-i

		String s = "1234";
		int i = Integer.parseInt(s);
        Integer it = Integer.valueOf(s);
		System.out.println(i);
		
        Similarly, 
        long l = Long.parseLong(s);
        Long l = Long.valueOf(String s).longValue();

		i++;
		String t = String.valueOf(i);
		System.out.println(t);

	For valid positive integer:

	private static int parseInt(String str) {
		int i, n = 0;

		for (i = 0; i < str.length(); i++) {
			n *= 10;
			n += str.charAt(i) - 48;
		}
		return n;
	}
	For both positive and negative integers:

	private static int parseInt(String str) {
		int i=0, n=0, sign=1;
		if(str.charAt(0) == '-') {
			i=1;
			sign=-1;
		}
		for(; i<str.length(); i++) {
			n*=10;
			n+=str.charAt(i)-48;
		}
		return sign*n;
	}
	 

	If you are expecting a whitespace before or after these numbers, then make sure to do a str = str.trim() before processing further.

32b. Difference between parseInt and valueOf in java?
    Well, the API for Integer.valueOf(String) does indeed say that the String is interpreted exactly as if it were given to Integer.parseInt(String). However, valueOf(String) returns a new Integer() object whereas parseInt(String) returns a primitive int

    If you want to enjoy the potential caching benefits of Integer.valueOf(int), you could also use this eyesore:
        Integer k = Integer.valueOf(Integer.parseInt("123"))

    Now, if what you want is the object and not the primitive, then using valueOf(String) may be more attractive than making a new object out of parseInt(String) because the former is consistently present across Integer, Long, Double, etc

33.
Iterating over a Map using EntrySet
http://stackoverflow.com/questions/5428897/why-do-we-use-entryset-method-and-use-the-retured-set-to-iterate-a-map

    This is as close to iterating over the map as we can because you have to say whether you want just the keys, just the values or the whole key/value entry.
    For Sets and Lists, there is only one option so, no need to have a separate method to do this.

    BTW: This is how I would iterate over a Map.

        Map<K,V> m=new LinkedHashMap<K,V>();
        for(Map.Entry<K,V> entry: m.entrySet())
            System.out.println(entry.getKey() + ": " + entry.getValue());

    In Java 8 you can write
        m.forEach((k, v) -> System.out.println(k + ": " + v));

34.
Signed Right Shift and Unsigned Right Shift
http://www.geeksforgeeks.org/bitwise-shift-operators-in-java/

    >> (Signed right shift)
        In Java, the operator >> is signed right shift operator.
        All integers are signed in Java, and it is fine to use >> for negative numbers.
        The operator >> uses the sign bit (left most bit) to fill the trailing positions after shift.
        If the number is negative, then 1 is used as a filler and if the number is positive, then 0 is used as a filler.

    >>> (Unsigned right shift)
        In Java, the operator >>> is unsigned right shift operator.
        It always fills 0 irrespective of the sign of the number.

35.
Method Variables and Class Variables

    Class Variables:
        - All Class variables must be initialized if the variable is FINAL
        - If NO final, then the class variables gets the DEFAULT VALUE

    Method Variables:
        - Method variables MUST be initialized before being used

36.
Creating Java Objects

    The only way to create a new object in Java is with new [1].
    However, in some classes, you're not permitted to say new for yourself, you must call a factory method, which might be static (as with your logger example) or not.

37.
Why Java string does not need new to create

    String literals [ie, Strings like "abcd" but not like new String("abcd")] in Java are interned - this means that every time you refer to "abcd", you get a reference to a single String instance, rather than a new one each time.

    So you will have
        String a = "abcd";
        String b = "abcd";

        a == b; //True

    but if you had
        String a = new String("abcd")
        String b = new String("abcd")

    then its possible to have
        a == b; // False

    (and in case anyone needs reminding, always use .equals() to compare Strings; == tests for physical equality)

    Interning String literals is good because they are often used more than once. For example, consider the (contrived) code:

        for (int i = 0; i < 10; i++) {
          System.out.println("Next iteration");
        }

    If we didn't have interning of Strings, "Next iteration" would need to be instantiated 10 times, whereas now it will only be instantiated once.

38.
How are Java objects stored in memory

    When we only declare a variable of a class type, only a reference is created (memory is not allocated for the object).
    To allocate memory to an object, we must use new(). So the object is always allocated memory on heap

38b.
When is memory allocated
http://stackoverflow.com/questions/25055375/when-is-memory-allocated-during-instance-creating-or-using-new-keyword-for-objec

    Variables declared within a method are stored within the stack, while the actual objects are stored on the heap. Consider

        Integer a = new Integer(10);

    In this example, an object of type Integer is created on the heap and a reference (either 32 or 64bits) is returned and stored within the methods stack as variable 'a'.
    The JVM is free to keep variables like this within the CPU registers if it prefers as an optimization.

    Memory of an object is allocated when the new keyword is used.

39.
Java Pass by value or Pass by reference
http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value

    static void foo(Node root) {
        root = root.left;
        System.out.println("Inside foo: " + root.data); // Prints 3
    }

    static void bar(Node root) {
        root.data = 100;
        System.out.println("Inside bar: " + root.data); // Prints 100
    }

    System.out.println("B4 foo: " + root.data); // Prints 3
    foo(root);
    System.out.println("After foo: " + root.data); // Prints 3

    System.out.println("B4 bar: " + root.data); // Prints 3
    bar(root);
    System.out.println("After bar: " + root.data); // Prints 100


    The key to understanding this is that something like
        Dog myDog;

    is not a Dog; it's actually a pointer to a Dog.

    What that means, is when you have you're essentially passing the address of the created Dog object to the foo method.
        Dog myDog = new Dog("Rover");
        foo(myDog);

    (I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)

    Suppose the Dog object resides at memory address 42. This means we pass 42 to the method.

    if the Method were defined as

        public void foo(Dog someDog) {
            someDog.setName("Max");     // AAA
            someDog = new Dog("Fifi");  // BBB
            someDog.setName("Rowlf");   // CCC
        }

    let's look at what's happening.

        the parameter someDog is set to the value 42
        at line "AAA"
            someDog is followed to the Dog it points to (the Dog object at address 42)
            that Dog (the one at address 42) is asked to change his name to Max
        at line "BBB"
            a new Dog is created. Let's say he's at address 74
            we assign the parameter someDog to 74
        at line "CCC"
            someDog is followed to the Dog it points to (the Dog object at address 74)
            that Dog (the one at address 74) is asked to change his name to Rowlf
        then, we return

    Now let's think about what happens outside the method:

    Did myDog change?

    There's the key.

    Keeping in mind that myDog is a pointer, and not an actual Dog, the answer is NO.
    myDog still has the value 42; it's still pointing to the original Dog (but note that because of line "AAA", its name is now "Max" - still the same Dog; myDog's value has not changed.)

    --------
    Java is always pass-by-value.
    Unfortunately, they decided to call pointers references, thus confusing newbies.
    Because those references are passed by value.

    It goes like this:
        public static void main( String[] args ){
            Dog aDog = new Dog("Max");
            foo(aDog);

            if (aDog.getName().equals("Max")) { //true
                System.out.println( "Java passes by value." );

            } else if (aDog.getName().equals("Fifi")) {
                System.out.println( "Java passes by reference." );
            }
        }

        public static void foo(Dog d) {
            d.getName().equals("Max"); // true

            d = new Dog("Fifi");
            d.getName().equals("Fifi"); // true
        }

    In this example aDog.getName() will still return "Max".
    The value aDog within main is not overwritten in the function foo with the Dog "Fifi" as the object reference is passed by value.
    If it were passed by reference, then the aDog.getName() in main would return "Fifi" after the call to foo.

    Likewise:
        Dog aDog = new Dog("Max");
        foo(aDog);
        aDog.getName().equals("Fifi"); // true
        public void foo(Dog d) {
            d.getName().equals("Max"); // true
            d.setName("Fifi");
        }

    In the above example, FiFi is the dog's name after call to foo(aDog).
    Any operations that foo performs on d are such that, for all practical purposes, they are performed on aDog itself (except d=new Dog("Boxer")).

40.
Check ArrayLists is empty

    isEmpty() to check if arrayList is empty.

41.
Check if Array is empty
    
    int[] arr = null;
    if (arr == null || arr.length == 0)

	int[] a = new int[5]; // Array is NOT EMPTY AND NOT NULL
	if (a == null) {
		System.out.println("NULL"); // Won't print
	}
	if (a.length == 0) {
		System.out.println("Empty"); // Won't print
	}
	System.out.println("Done"); // Gets printed

42.
Convert Array to ArrayList

    new ArrayList<Element>(Arrays.asList(array))

42a. How to convert int[] into List<Integer> in Java?
    There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> which is not what you want. 

    List<Integer> Ints.asList(int...)
    
    int[] ints = {1,2,3};
    List<Integer> list = Arrays.stream(ints).boxed().collect(Collectors.toList());

42b. Convert Array to Set
https://stackoverflow.com/questions/3064423/how-to-convert-an-array-to-a-set-in-java
    Set<String> s = new HashSet<String>(
        Arrays.asList(new String[] { "1", "2", "3" }));

42c.
Convert ArrayList to Array in Java

    String[] dsf = new String[al.size()];
    al.toArray(dsf);

    String names[]=list.toArray(new String[list.size()])

42c. 
How to convert List<Integer> to int[] in Java?
https://stackoverflow.com/questions/960431/how-to-convert-listinteger-to-int-in-java

    1. Unfortunately, I don't believe there really is a better way of doing this due to the nature of Java's handling of primitive types, boxing, arrays and generics. In particular:

    List<T>.toArray won't work because there's no conversion from Integer to int

    2. Using strams:
        int[] array = list.stream().mapToInt(i->i).toArray();

    3. 
    In addition to Commons Lang, you can do this with Guava's method Ints.toArray(Collection<Integer> collection):

        List<Integer> list = ...
        int[] ints = Ints.toArray(list);

    4. 
        int[] toIntArray(List<Integer> list)  {
            int[] ret = new int[list.size()];
            int i = 0;
            for (Integer e : list)  
                ret[i++] = e.intValue();
            return ret;
        }

43.
Integer MAX_VALUE
    
    int i = Integer.MAX_VALUE;

44.
Char array to String

    char[] a = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};
    String b = new String(a);

45.
String to Char Array

    String.toCharArray();

46.
Length Length() and Size()

    length --- arrays (int[], double[], String[]) ---- to know the length of the arrays
    length() --- String related Object (String, StringBuilder etc)to know the length of the String
    size() --- Collection Object (ArrayList, Set etc)to know the size of the Collection 

47.
How to use Iterator in Java

        List<String> list = new ArrayList<String>();

		System.out.println("#4 iterator");
		Iterator<String> iterator = list.iterator();

		while (iterator.hasNext())
        {
			System.out.println(iterator.next());
		}

48.
Generating Random Number
http://stackoverflow.com/questions/363681/generating-random-integers-in-a-specific-range 
http://stackoverflow.com/questions/5887709/getting-random-numbers-in-java

    Seed for random:
        Random random = new Random(System.currentTimeMillis());

    0. Generating Random Number between 1 and N
        a. Math.random
            random() method returns a random number between 0.0 and 0.999

            double random = Math.random() * 50 + 1;
            or
            int random = (int )(Math.random() * 50 + 1);

        b.
            Random rand = new Random(); 
            int value = rand.nextInt(50);

            This will give value from 0 to 49.
            For 1 to 50: rand.nextInt((max - min) + 1) + min;

    1. Generating Random Number in a Range between Min and Max
        a.
            Min + (int)(Math.random() * ((Max - Min) + 1))
            This returns a value in the range [0,Max-Min), where 'Max-Min' is not included.

        b.
            import java.util.concurrent.ThreadLocalRandom;

            // nextInt is normally exclusive of the top value,
            // so add 1 to make it inclusive
            ThreadLocalRandom.current().nextInt(min, max + 1);

49.
Using Synchronized in Java
http://tutorials.jenkov.com/java-concurrency/synchronized.html
https://stackoverflow.com/questions/6214229/question-about-java-synchronized

    synchronized only prevents multiple threads from simultaneously executing the method in the same instance. If you have n instances, there could be n threads, each executing the method in one of the instances.

    If you need to ensure that only one thread may execute the method across all instances, you should make the method static, or make the method non-synchronized and rather use a synchronized block inside the method to lock on a private static field.

    Edit: Note that synchronizing on a private instance variable is preferrable to having a synchronized method or to synchronize on this, and that locking on a private static instance variable is preferrable to having a static synchronized method or an instance method that synchronizes on this.getClass(). The reason is that this and this.getClass() are object references that are accessible throughout the program, so anybody may synchronize on these objects, and thereby block threads that want to call your method.

 The synchronized keyword can be used to mark four different types of blocks:

    1. Instance methods
          public synchronized void add(int value){
          this.count += value;
      }

    2. Static methods
          public static synchronized void add(int value){
              count += value;
          }
    3. Code blocks inside instance methods
          public void add(int value){

            synchronized(this){
               this.count += value;   
            }
          }
    4. Code blocks inside static methods
        public static void log2(String msg1, String msg2){
           synchronized(MyClass.class){
              log.writeln(msg1);
              log.writeln(msg2);  
           }
        }

49b.
Java synchronized method lock on object, or method?

    If I have 2 synchronized methods in the same class, but each accessing different variables, can 2 threads access those 2 methods at the same time? Does the lock occur on the object, or does it get as specific as the variables inside the synchronized method?

    Example:
        class X {

            private int a;
            private int b;

            public synchronized void addA(){
                a++;
            }

            public synchronized void addB(){
                b++;
            }

        }
    Can 2 threads access the same instance of class X performing x.addA() and x.addB() at the same time?

    If you declare the method as synchonized (as you're doing by typing public synchronized void addA()) you synchronize on the whole object, so two thread accessing a different variable from this same object would block each other anyway.

    If you want to synchronize only on one variable at a time, so two threads won't block each other while accessing different variables, you have synchronize on them separately in synchronized () blocks. If a and b were object references you would use:

        public void addA() {
            synchronized( a ) {
                a++;
            }
        }
        public void addB() {
            synchronized( b ) {
                b++;
            }
        }
    But since they're primitives you can't do this.

49c. Synchronized Block vs Method

    When you synchronize a method, you are effectively synchronizing to the object itself. In the case of a static method, you're synchronizing to the class of the object. So the following two pieces of code execute the same way:

    public synchronized int getCount() {
        // ...
    }
    This is just like you wrote this.

    public int getCount() {
        synchronized (this) {
            // ...
        }
    }
    If you want to control synchronization to a specific object, or you only want part of a method to be synchronized to the object, then specify a synchronized block.

    Although not usually a concern, from a security perspective, it is better to use synchronized on a private object, rather than putting it on a method.

    Putting it on the method means you are using the lock of the object itself to provide thread safety. With this kind of mechanism, it is possible for a malicious user of your code to also obtain the lock on your object, and hold it forever, effectively blocking other threads. A non-malicious user can effectively do the same thing inadvertently.

    If you use the lock of a private data member, you can prevent this, since it is impossible for a malicious user to obtain the lock on your private object.

    private final Object lockObject = new Object();

    public void getCount() {
        synchronized( lockObject ) {
            ...
        }
    }

50.
Converting int to Integer and Integer to int
http://stackoverflow.com/questions/4052085/passing-integer-to-int-and-vice-versa

    This is auto-boxing and auto-unboxing.
    Basically the compiler puts in calls to Integer.valueOf() or x.intValue() appropriately

51.
Iterator for LinkedHashMap
http://stackoverflow.com/questions/13735574/how-do-i-iterate-through-a-java-linked-hash-map

    Map<String, User> users = new LinkedHashMap<String, User>();
    users.put(name, user);

    for (Map.Entry<String,User> entry : users.entrySet()) {
        // entry.getValue() is of type User now
    }

    Iterator<User> it = users.values().iterator();
    while (it.hasNext())
    {
      User currentUser = it.next();
      currentUser.someMethod();
    }

52.
What are Packages

    - Packaging breaks down projects into meaningful segments
    - I a large application, you are bound to have two files named exactly the same (java.util.Date and java.sql.Date), especially when you start bringing in third party jars.
    - Ensure uniqueness.
    - A Java package is a mechanism for organizing Java classes into namespaces similar to the modules of Modula.
    - Java packages can be stored in compressed files called JAR files, allowing classes to download faster as a group rather than one at a time.
    - Programmers also typically use packages to organize classes belonging to the same category or providing similar functionality.

    - Preventing naming conflicts.
    - Making searching/locating and usage of classes, interfaces, enumerations and annotations easier
    - Providing controlled access: protected and default have package level access control
    - Packages can be considered as data encapsulation (or data-hiding).

53.
What is CLASSPATH
https://stackoverflow.com/questions/2396493/what-is-a-classpath

    - Think of it as Java's answer to the PATH environment variable
    - OSes search for EXEs on the PATH.
    - Java searches for classes and packages on the classpath

    When programming in Java, you make other classes available to the class you are writing by putting something like this at the top of your source file:
        import org.javaguy.coolframework.MyClass;

    Or sometimes you 'bulk import' stuff by saying:
        import org.javaguy.coolframework.*;

    So later in your program when you say:
        MyClass mine = new MyClass();

    The Java Virtual Machine will know where to find your compiled class.

    It would be impractical to have the VM look through every folder on your machine, so you have to provide the VM a list of places to look.
    This is done by putting folder and jar files on your classpath

    Before we talk about how the classpath is set, let's talk about .class files, packages, and .jar files.

    First, let's suppose that MyClass is something you built as part of your project, and it is in a directory in your project called output. The .class file would be at output/org/javaguy/coolframework/MyClass.class (along with every other file in that package). In order to get to that file, your path would simply need to contain the folder 'output', not the whole package structure, since your import statement provides all that information to the VM.

    Now let's suppose that you bundle CoolFramework up into a .jar file, and put that CoolFramework.jar into a lib directory in your project. You would now need to put lib/CoolFramework.jar into your classpath. The VM will look inside the jar file for the org/javaguy/coolframework part, and find your class.

    So, classpaths contain:
        JAR files, and
        Paths to the top of package hierarchies.

54.
What is Strongly Typed / Weak Typed, Static Typed and Dynamic Typed Language
http://stackoverflow.com/questions/2351190/static-dynamic-vs-strong-weak
    - Java is statically typed and also a strongly typed language

    - Don't use the terms "strong" and "weak" typing, because they don't have a universally agreed on technical meaning

    - Static/Dynamic typing is about when type information is aquired (Either at compiletime or at runtime)

    - Strong/Weak typing is about how strictly types are distinguished (e.g. whether the language tries to do implicit conversion from strings to numbers)

55.
C++ Features Missing in Java

    No pointers
    No sizeof operator
    No scope resolution operator
    Local variables in functions cannot be static
    No Multiple Inheritance
    No Operator Overloading
    No preprocessor and macros
    No user suggested inline functions
    No goto
    No default arguments
    No unsigned int in Java
    No -> operator in java
    No stack allocated objects in java
    No delete operator in java due to javas garbage collection
    No destructor in java
    No typedef in java
    No global variables, no global function because java is pure OO.
    No friend functions
    No friend classes
    No templates in java

56.
Java Main Class need not be Public
http://www.geeksforgeeks.org/myth-file-name-class-name-java/

    - It is just that the standard enforces using Public class 

    If Main class is not Public, following error gets generated
        javac Trial.java
        Trial.java:9: error: class Geeks is public, should be
                            declared in a file named Geeks.java
        public class Geeks

    But the myth can be violated in such a way to compile the above file.
        /***** File name: Trial.java ******/
        class Geeks
        {
            public static void main(String[] args) {
                System.out.println("Hello world");
            }
        }

    Step 1: javac Trial.java
        Step1 will create a Geeks.class (byte code) without any error message since the class is not public.

    Step 2: java Geeks
        Now the output will be Hello world

    /*** File name: Trial.java ***/
    class ForGeeks
    {
       public static void main(String[] args){
          System.out.println("For Geeks class");
       }
    }
     
    class GeeksTest
    {
       public static void main(String[] args){
          System.out.println("Geeks Test class");
       }
    }

    When the above file is compiled as javac Trial.java will create two .class files as ForGeeks.class and GeeksTest.class .
    Since each class has separate main() stub they can be tested individually.
    When java ForGeeks is executed the output is For Geeks class.
    When java GeeksTest is executed the output is Geeks Test class.

57.
What is Volatile in Java

     "volatile" tells the compiler that the value of a variable must never be cached as its value may change outside of the scope of the program itself.

    The values of volatile variable will never be cached and all writes and reads will be done to and from the main memory.
    However, use of volatile is limited to very restricted set of cases as most of the times atomicity is desired

58.
Can't use INT as Bool in condition
http://stackoverflow.com/questions/13806021/checking-the-boolean-result-of-an-int-type

    int i = 5;
    if (i) <-- Fails

    int y = (int)(i == 5); <--- Fails too

59.
>>> and >>
    >> is arithmetic shift right, >>> is logical shift right.

    In an arithmetic shift, the sign bit is extended to preserve the signedness of the number.

60.
try catch throw throws finally

    - Checked Exception
        - These are compile time exceptions
    - Unchecked Excpetion:
        - These are Runtime exception
    - Try must have a catch or finally
    - throw to throw custom exception
    - Throwable is a super class for all types of errors and exceptions in java.

    - "Throws keyword" is mainly used for handling checked exception as using throws we can declare multiple exceptions in one go.
    1. The throws keyword is used in method declaration, in order to explicitly specify the exceptions that a particular method might throw.
    When a method declaration has one or more exceptions defined using throws clause then the method-call must handle all the defined exceptions.

    2. When defining a method you must include a throws clause to declare those exceptions that might be thrown but doesnt get caught in the method.

    3. If a method is using throws clause along with few exceptions then this implicitly tells other methods that   If you call me, you must handle these exceptions that I throw.

        class MyOwnException extends Exception {
           public MyOwnException(String msg){
              super(msg);
           }
        }

        class EmployeeTest {
           static void  employeeAge(int age) throws MyOwnException{
              if(age < 0)
                 throw new MyOwnException("Age can't be less than zero");
              else
                 System.out.println("Input is valid!!");
           }
           public static void main(String[] args) {
               try {
                    employeeAge(-2);
               }
               catch (MyOwnException e) {
                    e.printStackTrace();
               }
           }
        }

61.
What is finalize

    finalize is present in every Object
    - If we want to do some type of cleanup before the object gets cleaned by the garbage
      collector, we can add those inside finalize method in the Class

62.
Create 2D Array in Java

    1.
    int[][] multi = new int[5][10];

    2.
    int[][] multi = new int[5][];
    multi[0] = new int[10];
    multi[1] = new int[10];
    multi[2] = new int[10];
    multi[3] = new int[10];
    multi[4] = new int[10];

    3.
    int marks[][]={{50,60,55,67,70},{62,65,70,70,81},{72,66,77,80,69}};

63.
Access Specifiers in Java

    Classes and Interfaces can have only two access specifiers when declared outside any other class.
    1) public
    2) default (when no access specifier is specified)

    Methods and Members:
    Access Levels
    Modifier 	Class 	Package 	Subclass 	World
    public 	    Y 	    Y 	        Y 	        Y
    protected 	Y 	    Y 	        Y 	        N
    no modifier	Y 	    Y 	        N 	        N
    private 	Y 	    N 	        N 	        N

64.
Convert base2 string to decimal
    int decimalValue = Integer.parseInt(c, 2);

64b. Convert decimal to binary, octal, hex
    Integer.toString(n,8) // decimal to octal
    Integer.toString(n,2) // decimal to binary
    Integer.toString(n,16) //decimal to Hex

64c. Count number of bits in a number
    Integer.bitCount(int);
    Long.bitCount(long);

    int no = 12345;
    int count;
    for (count = 0; no > 0; ++count) {
      no &= no - 1;
    }

65.
Convert a char to an int or Get numeric value of a character

        char c= '5';
        Character.getNumericValue(c)

66.
What is THIS
    Anit:
    When an object is created a invisible "this" gets created.
    When we call a method through the object, "this" gets passed

67.
Java Heap Old gen, Perm Gen and Young gen
http://stackoverflow.com/questions/2129044/java-heap-terminology-young-old-and-permanent-generations

http://stackoverflow.com/questions/3849634/static-allocation-in-java-heap-stack-and-permanent-generation/3849819#3849819

https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html

68.
Declare array in Java

        int[] myIntArray = new int[3];
        int[] myIntArray = {1,2,3};
        int[] myIntArray = new int[]{1,2,3};

    For classes, for example String, it's the same:
        String[] myStringArray = new String[3];
        String[] myStringArray = {"a","b","c"};
        String[] myStringArray = new String[]{"a","b","c"};

69.
Boolean[] vs BitSet
http://stackoverflow.com/questions/605226/boolean-vs-bitset-which-is-more-efficient

    From some benchmarks with Sun JDK 1.6 computing primes with a sieve (best of 10 iterations to warm up, give the JIT compiler a chance, and exclude random scheduling delays, Core 2 Duo T5600 1.83GHz):

    BitSet is more memory efficient than boolean[] except for very small sizes.
    Each boolean in the array takes a byte.
    The numbers from runtime.freeMemory() are a bit muddled for BitSet, but less.

    boolean[] is more CPU efficient except for very large sizes, where they are about even.
    E.g., for size 1 million boolean[] is about four times faster (e.g. 6ms vs 27ms), for ten and a hundred million they are about even.

        BitSet bs1 = new BitSet();
        BitSet bs2 = new BitSet(6);
        bs1.set(0);
        bs1.set(1);
        bs1.get(0); -> boolean

70.
ArrayList get set

        int t = arr.get(0);
        arr.set(0, arr.get(1));
        arr.set(1, t);

71.
Array and ArrayList pass reference by value

    So value gets changed in caller

        {
	    int[] c = new int[2];
	    c[0] = 5;
	    c[1] = 3;
	    System.out.println(c[0]);
	    System.out.println(c[1]);
	    System.out.println();
	    
	    mySwap(c);
	    System.out.println(c[0]);
	    System.out.println(c[1]);
	    
	    ArrayList<Integer> al = new ArrayList<>();
	    al.add(5);
	    al.add(3);
	    System.out.println(al);
	    
	    mySwap2(al);
	    System.out.println(al);
        }

        static void mySwap(int[] arr)
        {
            int t = arr[0];
            arr[0] = arr[1];
            arr[1] = t;
        }
        
        static void mySwap2(ArrayList<Integer> arr)
        {
            int t = arr.get(0);
            arr.set(0, arr.get(1));
            arr.set(1, t);
        }

72.
Change a character in a String

    String are immutable in Java. You can't change them.
    You need to create a new string with the character replaced.

        String myName = "domanokz";
        String newName = myName.substring(0,4)+'x'+myName.substring(5);

    Or you can use a StringBuilder:
        StringBuilder myName = new StringBuilder("domanokz");
        myName.setCharAt(4, 'x');

        System.out.println(myName);

73.
Java FileChannel - Java NIO
https://examples.javacodegeeks.com/core-java/nio/filechannel/java-nio-channels-filechannel-example/

    - NIO - New IO
    - NIO allows Java programmers to implement high-speed I/O without having to write custom native code.
    - NIO moves the most time consuming I/O activities (like, filling and draining buffers) back into the operating system, thus providing increase in speed.
    - NIO makes I/O faster than traditional I/O.

    - File channels are read/write channels and they are always blocking.
    - This is a channel for reading, writing, mapping, and manipulating a file. FileChannel objects are thread-safe.

74.
    @Override
    It's a hint for the compiler to let it know that you're overriding the method of a parent class (or interface in Java 6).

    If the compiler detects that there IS no function to override, it will warn you (or error).

    This is extremely useful to quickly identify typos or API changes.
    Say you're trying to override your parent class' method harvest() but spell it harvset(), your program will silently call the base class, and without @Override, you wouldn't have any warning about that.

75.
Get Boolean from a String
    Boolean boolean1 = Boolean.valueOf("true");
    boolean boolean2 = Boolean.parseBoolean("true");
    Advantage:

    Boolean: this does not create new instances of Boolean, so performance is better (and less garbage-collection). It reuses the two instances of either Boolean.TRUE or Boolean.FALSE.
    boolean: no instance is needed, you use the primitive type.

76.
Try Catch Throws - Komprise
    - You don't have to catch a Local Exception and another another string or message to it.
    - You just throw it as such

    - Add all your exceptions to local exception
    - Finally before throwing the local exception, log and throw it

77.
String concatenation for Logging {} vs +
http://stackoverflow.com/questions/2245088/how-to-display-stack-trace-on-a-caught-exception
https://stackoverflow.com/questions/8755063/concatenation-operator-vs-concat

    The concat method always produces a new String with the result of concatenation.

    The plus operator is backed by StringBuilder creation, appending all String values you need and further toString() calling on it.

    So, if you need to concatenate two values, concat() will be better choice. If you need to concatenate 100 values, you should use the plus operator or explicitly use StringBuilder (e.g. in case of appending in a cycle).

	--------
	In fact s1 + s2 and s1.concat(s2) are very different.

	s1 + s2 is converted by javac into

	(new StringBuilder(String.valueOf(s1)).append(s2).toString();
	You can see it if you decompile .class. This construct is not very efficient; it involves up to three new char[] allocations and three char[] copy operations.

	s1.concat(s2) is always one new char[] + one copy operation, see String.java

	public String concat(String str) {
		int otherLen = str.length();
		if (otherLen == 0) {
			return this;
		}
		char buf[] = new char[count + otherLen];
		getChars(0, count, buf, 0);
		str.getChars(0, otherLen, buf, count);
		return new String(0, count + otherLen, buf);
	}
	Note that new String(int, int, char[]) is String's package private constructor. It uses char buf[] directly, without the usual copying to ensure the buf invisibility for the String immutability.
	--------
	I believe the 'style' of concatenation is going to make a difference.

	For concat(), it internally creates a new char array buffer, and returns a new string based on that char array.

	For the + operator, the compiler in fact translate it to use StringBuffer/StringBuilder.

	Therefore, if you are concatenating two strings, concat() is definitely a better choice because the number of objects created is only the result String (and the char buffer used inside), while using the  + operator will be translated to:

	result = strA + strB;
	-- translate to -->
	result = new StringBuilder(strA).append(strB).toString();
	An extra StringBuilder instance is created.

	However, if you are concatenating, for example five strings in a row, each concat() will create a new String object. While using the + operator, the compiler will translate the statement to one StringBuilder with multiple append operations. It is definitely saving a lot of unnecessary temporary object instance:

	result = strA + strB + strC + strD + strE;
	-- translate to -->
	result = new StringBuilder(strA).append(strB).append(strC).append(strD).append(strE).toString();

78.
Logging exception
http://stackoverflow.com/questions/10555409/logger-slf4j-advantages-of-formatting-with-instead-of-string-concatenation

79.
How to fix Could not find or load main class error
    Run using java -cp . 

80.
Run class inside a jar, MVN Building app into JAR with all dependencies and running the app - Fat JAR
    Change pom.xml to include the following

    Converting Java Program to Jar:
    http://stackoverflow.com/questions/2887473/how-to-convert-java-program-into-jar

    Add a MANIFEST.MF file:
        Manifest-Version: 1.2
        Main-Class: your.package.Main

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>fully.qualified.MainClass</mainClass>
                        </manifest>
                    </archive>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                </configuration>
            </plugin>

            <plugin>
                <!-- Build an executable JAR -->
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.0.2</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <classpathPrefix>lib/</classpathPrefix>
                            <mainClass>prag.jacksonXml.App</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>

	Compile using mvn:
	http://stackoverflow.com/questions/574594/how-can-i-create-an-executable-jar-with-dependencies-using-maven
		mvn clean compile assembly:single

    Run the jar using
    Run java from Jar, Run class inside a jar
        java -cp jacksonXml-1.0-SNAPSHOT-jar-with-dependencies.jar prag.jacksonXml.App

81.
How to resolve Could not find or load main class Foo error
    java -cp . Foo

    Where Foo.java is the hello world program

82. 
Print a list using forEach
    list.forEach(System.out::println);

82b.
For each to on String 
    for (char c : str.toCharArray())

83.
How to convert Java String into byte[]?
http://stackoverflow.com/questions/18571223/how-to-convert-java-string-into-byte

    byte[] b = string.getBytes();
    byte[] b = string.getBytes(Charset.forName("UTF-8"));
    byte[] b = string.getBytes(StandardCharsets.UTF_8); // Java 7+ only

    String str = "hello";
    byte[] b = str.getBytes(StandardCharsets.UTF_8); // Java 7+ only
    String string = new String(b, StandardCharsets.UTF_8);
    System.out.println(Arrays.toString(b));
    System.out.println(string);

83b.
Convert integer into byte array (Java)

    ByteBuffer b = ByteBuffer.allocate(4);
    //b.order(ByteOrder.BIG_ENDIAN); // optional, the initial order of a byte buffer is always BIG_ENDIAN.
    b.putInt(0xAABBCCDD);

    byte[] result = b.array();

84.
Is there an equivalent to memcpy() in Java?
http://stackoverflow.com/questions/3329163/is-there-an-equivalent-to-memcpy-in-java

		byte[] src = {1, 2, 3, 4};
		byte[] dst = Arrays.copyOf(src, src.length);
		System.out.println(Arrays.toString(dst));

	OR
		Use System.arraycopy()

		System.arraycopy(sourceArray, 
						 sourceStartIndex,
						 targetArray,
						 targetStartIndex,
						 length);
		Example,

			  String[] source = { "alpha", "beta", "gamma" };
			  String[] target = new String[source.length];
			  System.arraycopy(source, 0, target, 0, source.length);

85.
Print an integer in binary format in Java
http://stackoverflow.com/questions/5263187/print-an-integer-in-binary-format-in-java

	int x = 100;
	System.out.println(Integer.toBinaryString(x));

	Integer.toString(100,8) // prints 144 --octal representation
	Integer.toString(100,2) // prints 1100100 --binary representation
	Integer.toString(100,16) //prints 64 --Hex representation

86.
Converting Little Endian to Big Endian
http://stackoverflow.com/questions/3842828/converting-little-endian-to-big-endian

	int little2big(int i) {
		return (i&0xff)<<24 | (i&0xff00)<<8 | (i&0xff0000)>>8 | (i>>24)&0xff;
	}

87.
StringBuffer vs StringBuilder vs String
http://stackoverflow.com/questions/1532461/stringbuilder-vs-string-concatenation-in-tostring-in-java

    Use StringBuilder when concatenating Strings inside a loop
    Compiler will take care of String concatenation outside the loop

https://www.geeksforgeeks.org/g-fact-27-string-vs-stringbuilder-vs-stringbuffer/

    // Concatenates to String
    public static void concat1(String s1) {
        s1 = s1 + "forgeeks";
    }

    // Concatenates to StringBuilder
    public static void concat2(StringBuilder s2) {
        s2.append("forgeeks");
    }

    // Concatenates to StringBuffer
    public static void concat3(StringBuffer s3) {
        s3.append("forgeeks");
    }

    1. Concat1 : In this method, we pass a string “Geeks” and perform “s1 = s1 + ”forgeeks”. The string passed from main() is not changed, this is due to the fact that String is immutable. Altering the value of string creates another object and s1 in concat1() stores reference of new string. References s1 in main() and cocat1() refer to different strings.

    2. Concat2 : In this method, we pass a string “Geeks” and perform “s2.append(“forgeeks”)” which changes the actual value of the string (in main) to “Geeksforgeeks”. This is due to the simple fact that StringBuilder is mutable and hence changes its value.

    2. Concat3 : StringBuffer is similar to StringBuilder except one difference that StringBuffer is thread safe, i.e., multiple threads can use it without any issue. The thread safety brings a penalty of performance.

    WHEN TO USE WHICH ONE :
        If a string is going to remain constant throughout the program, then use String class object because a String object is immutable.
        If a string can change (example: lots of logic and operations in the construction of the string) and will only be accessed from a single thread, using a StringBuilder is good enough.
        If a string can change, and will be accessed from multiple threads, use a StringBuffer because StringBuffer is synchronous so you have thread-safety.

88.
How to read an unknown number of bytes from an inputStream (socket/socketServer)?
http://stackoverflow.com/questions/5690954/java-how-to-read-an-unknown-number-of-bytes-from-an-inputstream-socket-socke

    byte[] resultBuff = new byte[0];
    byte[] buff = new byte[1024];
    int k = -1;
    while((k = sock.getInputStream().read(buff, 0, buff.length)) > -1) {
        byte[] tbuff = new byte[resultBuff.length + k]; // temp buffer size = bytes already read + bytes last read
        System.arraycopy(resultBuff, 0, tbuff, 0, resultBuff.length); // copy previous bytes
        System.arraycopy(buff, 0, tbuff, resultBuff.length, k);  // copy current lot
        resultBuff = tbuff; // call the temp buffer as your result buff
    }
    System.out.println(resultBuff.length + " bytes read.");
    return resultBuff;

89.
Receive byte[] using ByteArrayInputStream from a socket
http://stackoverflow.com/questions/10475898/receive-byte-using-bytearrayinputstream-from-a-socket

    InputStream stream = socket.getInputStream();
    byte[] data = new byte[100];
    int count = stream.read(data);

90.
How can I convert a 4-byte array to an integer?
http://stackoverflow.com/questions/5616052/how-can-i-convert-a-4-byte-array-to-an-integer

    Big-endian:
    int x = java.nio.ByteBuffer.wrap(bytes).getInt();

    Little-endian:
    int x = java.nio.ByteBuffer.wrap(bytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt();

91.
Java ByteBuffer to String

    StandardCharsets.UTF_8

    To get the bytes from a String in a particular encoding, you can use a sibling getBytes() method:
      byte[] bytes = k.getBytes( Charset.forName("UTF-8" ));

    To put bytes with a particular encoding into a String, you can use a different String constructor:
       String v = new String( bytes, Charset.forName("UTF-8") );

92.
How to convert a String into an ArrayList?

    List<String> myList = new ArrayList<String>(Arrays.asList(s.split(",")));

93.
Default values to arguments in function
    
    Java does not have a way to do it

94.
Static classes in Java
    
    Can't create static classes without public

95.
What is try-with-resources

    It was introduced because of some resources used in Java (like SQL connections or streams) being difficult to be handled properly;
    as an example, in java 6 to handle a InputStream properly you had to do something like:
        InputStream stream = new MyInputStream(...);
        try {
            // ... use stream
        } catch(IOException e) {
           // handle exception
        } finally {
            try {
                if(stream != null) {
                    stream.close();
                }
            } catch(IOException e) {
                // handle yet another possible exception
            }
        }

    Do you notice that ugly double try? now with try-with-resources you can do this:
        try (InputStream stream = new MyInputStream(...)){
            // ... use stream
        } catch(IOException e) {
           // handle exception
        }
    and close() is automatically called, if it throws an IOException

96.
Sort list of strings
    Collections.sort(al, Collections.reverseOrder());
    Collections.sort(al);

96b. Sort array
    Arrays.sort(arr);

97. Using enum

    private enum Color {
        RED("RED"),
        BLUE("BLUE");

        private final String color;

        private Color(String val) {
            this.color = val;
        }

        public String getColor() {
            return color;
        }
    }

    main() {
        String s = "RED";
        System.out.println(Color.valueOf(s));

        String strColor = Color.RED.name();
        Color enumColor = Color.valueOf(s);

        switch (enumColor) {
            case RED:
                System.out.println("Color is RED");
                break;
            case BLUE:
                System.out.println("Color is BLUE");
                break;
            default:
                System.out.println("Color is Invalid");
                break;
        }
    }

98. Collection.containsAll()
    String elements[] = { "A", "B", "C", "D", "E" };
    Set set = new HashSet(Arrays.asList(elements));

    elements = new String[] { "A", "B", "C" };
    Set set2 = new HashSet(Arrays.asList(elements));

    System.out.println(set.containsAll(set2));

99. Add a list in a hashset using addAll
	List<Integer> a = new ArrayList<Integer>();
	a.add(20);

	List<Integer> b = new ArrayList<Integer>();
	b.add(30);

	Set<Integer> set = new HashSet<Integer>(a);
	set.addAll(b);

100. Convert list to a set
	Set<Foo> foo = new HashSet<Foo>(myList);

101. Comparing and removing elements not present in a List and array java
    You can use the methods the List interface provides.
    list.removeAll(Arrays.asList(array)); // Differences removed
    list.retainAll(Arrays.asList(array)); // Same elements retained

102. Convert List<String> to List<Integer> directly
    stringList.stream().map(Integer::parseInt).collect(Collectors.toList());

103. Communication between java threads: stopping all threads when one finishes its task
    https://stackoverflow.com/questions/17166918/communication-between-java-threads-stopping-all-threads-when-one-finishes-its-t
    https://stackoverflow.com/questions/19480162/java-threads-close-other-threads-when-first-thread-completes

104. Multithreading - Callable vs Runnable and Future
    http://www.geeksforgeeks.org/callable-future-java/
    http://www.concretepage.com/java/java-callable-example
    http://javarevisited.blogspot.com/2015/06/how-to-use-callable-and-future-in-java.html
    http://howtodoinjava.com/core-java/multi-threading/threadpoolexecutor-callable-future-example/

    There are two ways of creating threads – one by extending the Thread class and other by creating a thread with a Runnable. However, one feature lacking in  Runnable is that we cannot make a thread return result when it terminates, i.e. when run() completes. For supporting this feature, the Callable interface is present in Java.

    1. For implementing Runnable, the run() method needs to be implemented which does not return anything, while for a Callable, the call() method needs to be implemented which returns a result on completion. Note that a thread can’t be created with a Callable, it can only be created with a Runnable
    2. Another difference is that the call() method can throw an exception whereas run() cannot.

104b1. Multithreading - “implements Runnable” vs. “extends Thread”
    https://stackoverflow.com/questions/541487/implements-runnable-vs-extends-thread
    
    Implements Runnable is the preferred way to do it, IMO. You're not really specialising the thread's behaviour. You're just giving it something to run. That means composition is the philosophically "purer" way to go.

    Caveat: Around here, I strongly discourage the use of raw Threads. I much prefer the use of Callables and FutureTasks (From the javadoc: "A cancellable asynchronous computation"). The integration of timeouts, proper cancelling and the thread pooling of the modern concurrency support are all much more useful to me than piles of raw Threads.

    Follow-up: there is a FutureTask constructor that allows you to use Runnables (if that's what you are most comfortable with) and still get the benefit of the modern concurrency tools. To quote the javadoc:

    Moral of the story:
    Inherit only if you want to override some behavior.
    Or rather it should be read as:
    Inherit less, interface more.

104b1. Callable Future Example
https://howtodoinjava.com/core-java/multi-threading/threadpoolexecutor-callable-future-example/
            Executor.execute(() -> {
                // line or method;
            });

            new Thread(() -> {
                floorplanBundle.setCurrentFloorPlan(0);
            }).start();

            BlockingQueue<File> filesBlockingQueue = new ArrayBlockingQueue<>(filesInPath.size());
            filesBlockingQueue.addAll(filesInPath);

            ExecutorService executorService = Executors.newFixedThreadPool(FILE_THREAD_COUNT);
            int finalWordCount = 0;
            while (!filesBlockingQueue.isEmpty()) {
                Callable<Integer> task = () -> {
                    int wordVariationsCount = 0;
                    try {
                        File file = filesBlockingQueue.take();
                        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(file))) {
                            String currentLine;
                            while ((currentLine = bufferedReader.readLine()) != null) {
                                String[] words = currentLine.split("\\s+");
                                for (String word : words) {
                                    if (searchTextVariations.contains(word)) {
                                        wordVariationsCount++;
                                    }
                                }
                            }
                        } catch (Exception e) {
                            System.err.println("Failed to cound words in file=" + file + "; Exception=" + e);
                        }
                    } catch (Exception e) {
                        System.err.println("Failed to take file entry from files queue=" + e);
                    }
                    return wordVariationsCount;
                };
                finalWordCount += executorService.submit(task).get();
            }
            System.out.println("Final word count=" + finalWordCount);
            executorService.shutdown();

104b2. Creating new Threads
http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html

            static class ThreadClass implements Runnable {
                private IdGenerator id;

                public ThreadClass (IdGenerator id) {
                    this.id = id;
                }

                public void run() {
                    System.out.println(id.GetNextId());
                }
            }

            Thread th1 = new Thread(new Runnable() {
                public void run() {
                    System.out.println(id.GetNextId());
                }
            });
            th1.start();

            Thread th2 = new Thread(new ThreadClass(id));
            Thread th3 = new Thread(new ThreadClass(id));
            th2.start();
            th3.start();
            th1.join();
            th2.join();
            th3.join();

    Creating a thread in Java is done like this:
       Thread thread = new Thread();

    To start the Java thread you will call its start() method, like this:
        thread.start();

    Method 1:
        public class MyThread extends Thread {
            public void run(){
               System.out.println("MyThread running");
            }
        }

        MyThread myThread = new MyThread();
        myTread.start();

    You can also create an anonymous subclass of Thread like this:
        Thread thread = new Thread(){
            public void run(){
              System.out.println("Thread Running");
            }
        }
        thread.start();

    Method 2:
        public class MyRunnable implements Runnable {
            public void run(){
               System.out.println("MyRunnable running");
            }
        }
        Thread thread = new Thread(new MyRunnable());
        thread.start();

    You can also create an anonymous implementation of Runnable, like this:
        Runnable myRunnable = new Runnable(){
            public void run(){
                System.out.println("Runnable running");
            }
        }
        Thread thread = new Thread(myRunnable);
        thread.start();

    Using Lambda:
http://www.codejava.net/java-core/the-java-language/java-8-lambda-runnable-example
    // Lambda Runnable
    Runnable task2 = () -> { System.out.println("Runnable running"); };
     
     // start the thread
     new Thread(task2).start();

104b3. Creating dynamic number of threads
     Thread[] threads = new Thread[NUM_JOBS_TO_CREATE];
     for (int i = 0; i < threads.length; i++) {
         threads[i] = new Thread(new Runnable() {
             public void run() {
                 // some code to run in parallel
                 // this could also be another class that implements Runnable
             }
         });
         threads[i].start();
     }

    // wait for the threads running in the background to finish
    for (Thread thread : threads) {
        thread.join();
    }

104c. CountdownLatch
http://www.geeksforgeeks.org/countdownlatch-in-java/
https://stackoverflow.com/questions/17827022/how-is-countdownlatch-used-in-java-multithreading
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html

    A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.

    A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.

    A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown(). A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.

    A useful property of a CountDownLatch is that it doesn't require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. 

104d. Thread Signaling - wait(), notify() and notifyAll()
http://tutorials.jenkov.com/java-concurrency/thread-signaling.html
    A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object. In order to call either wait() or notify the calling thread must first obtain the lock on that object. In other words, the calling thread must call wait() or notify() from inside a synchronized block.

        public class MonitorObject{
        }

        public class MyWaitNotify{

          MonitorObject myMonitorObject = new MonitorObject();

          public void doWait(){
            synchronized(myMonitorObject){
              try{
                myMonitorObject.wait();
              } catch(InterruptedException e){...}
            }
          }

          public void doNotify(){
            synchronized(myMonitorObject){
              myMonitorObject.notify();
            }
          }
        }

    Missed Signals
    The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called. The notify signal is then just lost. Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread. This may or may not be a problem, but in some cases this may result in the waiting thread waiting forever, never waking up, because the signal to wake up was missed.

    Spurious Wakeups
    For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called. This is known as spurious wakeups. Wakeups without any reason.

    If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so! This could cause serious problems in your application.

    To guard against spurious wakeups the signal member variable is checked inside a while loop instead of inside an if-statement. Such a while loop is also called a spin lock.

    As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block. This is mandatory! A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on. If it does, an IllegalMonitorStateException is thrown.

	Facts about CountDownLatch:

    Creating an object of CountDownLatch by passing an int to its constructor (the count), is actually number of invited parties (threads) for an event.
    The thread, which is dependent on other threads to start processing, waits on until every other thread has called count down. All threads, which are waiting on await() proceed together once count down reaches to zero.
    countDown() method decrements the count and await() method blocks until count == 0

104d. Blocking queue and multi-threaded consumer, how to know when to stop
https://stackoverflow.com/questions/8974638/blocking-queue-and-multi-threaded-consumer-how-to-know-when-to-stop

        I have a single thread producer which creates some task objects which are then added into an ArrayBlockingQueue (which is of fixed size).

        I also start a multi-threaded consumer. This is build as a fixed thread pool (Executors.newFixedThreadPool(threadCount);). I then submit some ConsumerWorker intances to this threadPool, each ConsumerWorker having a refference to the above mentioned ArrayBlockingQueue instance.

        Each such Worker will do a take() on the queue and deal with the task.

        My issue is, what's the best way to have a Worker know when there won't be any more work to be done. In other words, how do I tell the Workers that the producer has finished adding to the queue, and from this point on, each worker should stop when he sees that the Queue is empty.

    You should continue to take() from the queue. You can use a poison pill to tell the worker to stop. For example:

    private final Object POISON_PILL = new Object();

    @Override
    public void run() {
        //worker loop keeps taking en element from the queue as long as the producer is still running or as 
        //long as the queue is not empty:
        while(isRunning) {
            System.out.println("Consumer "+Thread.currentThread().getName()+" START");
            try {
                Object queueElement = inputQueue.take();
                if(queueElement == POISON_PILL) {
                     inputQueue.add(POISON_PILL);//notify other threads to stop
                     return;
                }
                //process queueElement
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //this is used to signal from the main thread that he producer has finished adding stuff to the queue
    public void finish() {
        //you can also clear here if you wanted
        isRunning = false;
        inputQueue.add(POISON_PILL);
    }

104e. Does notify/notifyall release the lock being held
https://www.geeksforgeeks.org/inter-thread-communication-java/
    it is advised to use notify only at the end of your method. 

    notify()-It wakes up one single thread that called wait() on the same object. It should be noted that calling notify() does not actually give up a lock on a resource.

104f. Thread.sleep() does not release the lock. wait() releases the lock
https://stackoverflow.com/questions/1036754/difference-between-wait-and-sleep
    A wait can be "woken up" by another thread calling notify on the monitor which is being waited on whereas a sleep cannot.
    Also a wait (and notify) must happen in a block synchronized on the monitor object whereas sleep does not
    Another point is that you call wait on Object itself (i.e. you wait on an object's monitor) whereas you call sleep on Thread

    Yet another point is that you can get spurious wakeups from wait (i.e. the thread which is waiting resumes for no apparent reason). You should always wait whilst spinning on some condition as follows:

    synchronized {
        while (!condition) { mon.wait(); }
    }

105. Difference between Arrays.asList(array) vs new ArrayList<Integer>(Arrays.asList(ia)) in java
https://stackoverflow.com/questions/16748030/difference-between-arrays-aslistarray-vs-new-arraylistintegerarrays-aslist

    First, let's see what this does:

    Arrays.asList(ia)
    It takes an array ia and creates a wrapper that implements List<Integer>, which makes the original array available as a list. Nothing is copied and all, only a single wrapper object is created. Operations on the list wrapper are propagated to the original array. This means that if you shuffle the list wrapper, the original array is shuffled as well, if you overwrite an element, it gets overwritten in the original array, etc. Of course, some List operations aren't allowed on the wrapper, like adding or removing elements from the list, you can only read or overwrite the elements.

    Note that the list wrapper doesn't extend ArrayList - it's a different kind of object. ArrayLists have their own, internal array, in which they store their elements, and are able to resize the internal arrays etc. The wrapper doesn't have its own internal array, it only propagates operations to the array given to it.
    On the other hand, if you subsequently create a new array as

    new ArrayList<Integer>(Arrays.asList(ia))
    then you create new ArrayList, which is a full, independent copy of the original one. Although here you create the wrapper using Arrays.asList as well, it is used only during the construction of the new ArrayList and is garbage-collected afterwards. The structure of this new ArrayList is completely independent of the original array. It contains the same elements (both the original array and this new ArrayList reference the same integers in memory), but it creates a new, internal array, that holds the references. So when you shuffle it, add, remove elements etc., the original array is unchanged.


106. Can I compile a java file with a different name than the class?
https://stackoverflow.com/questions/1841847/can-i-compile-a-java-file-with-a-different-name-than-the-class
    Your Java file name should always reflect the public class defined within that file. Otherwise, you will get a compiler error. For example, test.java:

    public class Foo {}
    Trying to compile this gives:

    [steven@scstop:~]% javac test.java
    test.java:1: class Foo is public, should be declared in a file named Foo.java
    public class Foo {
           ^
           1 error

	But the myth can be violated in such a way to compile the above file.
	/***** File name: Trial.java ******/
	class Geeks
	{
		public static void main(String[] args) {
			System.out.println("Hello world");
		}
	}
	Run on IDE
	Step 1: javac Trial.java
	Step1 will create a Geeks.class (byte code) without any error message since the class is not public.

	Step 2: java Geeks
	Now the output will be Hello world

	The myth about the file name and class name should be same only when the class is declared in public.

107. Is main method compulsory in Java

    Prior to JDK 5, main method was not mandatory in a java program.

    You could write your full code under static block and it ran normally.
    The static block is first executed as soon as the class is loaded before the main(); method is invoked and therefore before the main() is called. main is usually declared as static method and hence Java doesn’t need an object to call main method.
     
     However, From JDK6 main method is mandatory. If your program doesn’t contain main method, then you will get a run-time error “main method not found in the class”. Note that your program will successfully compile in this case, but at run-time, it will throw error.

	// This program will successfully run
	// prior to JDK 5
	public class Test 
	{
		// static block
		static
		{
			System.out.println("program is running without main() method");
		}
	}

108. Java Data structures:

                Add         Get             Remove          Update      isPresent       Size        isEmpty     Clear
Array
ArrayList       add         get             remove          set         indexOf         size        isEmpty     clear
Stack           push        pop/peek                                    search          size        empty
Queue           add/offer   element/peek   remove/poll                                              isEmpty
PiorityQueue    add/offer   peek           remove/poll                  contains        size        isEmpty     clear
LinkedList      add/offer   element/peek   remove/poll                                              isEmpty
                addFirst(), addLast(), removeFirst, removeLast, pollFirst, pollLast
HashSet         add                        remove                       contains        size        isEmpty     clear
HashMap         put         get            remove           put         containsKey     size        isEmpty     clear
LinkedHashMap   put         get            remove           put         containsKey     size        isEmpty     clear

String: chatAt, equals, compareTo, indexOf, isEmpty, length, valueOf, substring, startsWith, split
Arrays: asList, binarySearch, fill, equals, sort


    1. Arrays
        a. arr.length;

    2. ArrayList
        a. add(E e)
        b. add(int index, E element)
        c. addAll(Collection<? extends E> c)
        d. clear()
        e. contains(Object o)
        f. get(int index)
        g. indexOf(Object o)
        h. isEmpty()
        i. lastIndexOf(Object o)
        j. remove(int index)
        k. remove(Object o)
        l. toArray()

    3. HashMap
           HashMap<Integer, Integer> sumMap = new HashMap<>();
        a. clear()
        b. containsKey(Object key)
        c. containsValue(Object value)
        d. entrySet()
        e. get(Object key)
        f. isEmpty()
        g. put(K key, V value)
        h. remove(Object key)
        i. remove(Object key, Object value)
           // Removes the entry for the specified key only if it is currently mapped to the specified value.
        j. Map.Entry<KeyType, ValueType> e : map.entrySet()
               e.getKey(), e.getValue()

    4. HashSet
        a. add(E e)
        b. clear()
        c. contains(Object o)
        d. isEmpty()
        e. remove(Object o)

    5. PriorityQueue
           PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        a. add(E e)
        b. clear()
        c. comparator()
        d. contains(Object o)
        e. offer(E e) // Does not throw an exception
        e. add(E e) // https://stackoverflow.com/questions/2703984/what-is-the-difference-between-the-add-and-offer-methods-in-a-queue-in-java
        f. peek()
        g. poll()
        h. remove(Object o)
        i. toArray()

    6. Queue
        a. queue.add() // Throws exception
        b. queue.remove() // Throws exception
        c. queue.element() // Get first element
        d. queue.isEmpty()
        d. queue.poll() // Does not throw exception

    I guess the difference is in the contract, that when element can not be added to collection the add method throws an exception and offer doesn't.

    If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.

    Inserts the specified element into this queue, if possible. When using queues that may impose insertion restrictions (for example capacity bounds), method offer is generally preferable to method Collection.add(E), which can fail to insert an element only by throwing an exception.

    7. Stack
        a. st.push()
        b. st.pop()
        c. st.peek()
        d. st.empty()
    8. LinkedHashMap
        a. lhm.put()
        b. lhm.containsKey()
        c. lhm.get()
        d. lhm.entrySet()
    9. LinkedList
        a. ll.add()
        b. ll.getFirst()
        c. ll.getLast()
    10. Google Multimap
           Multimap<Integer, Integer> sumMap = HashMultimap.create();
    BitSet
        BitSet uses about 1 bit per boolean value
        BitSet bs1 = new BitSet();
        BitSet bs2 = new BitSet(6);
        bs1.set(0);
        bs1.set(1);
        System.out.println(bs1.get(1));
        

109. Difference between int[] array and int array[]
    The [] is part of the TYPE, not of the NAME. For me, that's the biggest difference
    int[] a, b;  // Both a and b are arrays of type int
    int c[], d;  // WARNING: c is an array, but d is just a regular int


110. How to fill an array with certain value (zero fill)
    A default value of 0 for arrays of integral types is guaranteed by the language spec:
        Each class variable, instance variable, or array component is initialized with a default value when it is created (§15.9, §15.10) [...] For type int, the default value is zero, that is, 0.  
    If you want to initialize an array to a different value, you can use java.util.Arrays.fill() (which will of course use a loop internally).

110b. How can I initialize an ArrayList with all zeroes in Java?
https://stackoverflow.com/questions/5600668/how-can-i-initialize-an-arraylist-with-all-zeroes-in-java
    Q.
    It looks like arraylist is not doing its job for presizing:
    // presizing 
    ArrayList<Integer>() list = new ArrayList<Integer>(60);

    Afterwards when I try to access it:
    list.get(5) 

    It shows null instead of 0

    A.
    The integer passed to the constructor represents its initial capacity, i.e., the number of elements it can hold before it needs to resize its internal array (and has nothing to do with the initial number of elements in the list).

    To initialize an list with 60 zeros you do:
    List<Integer> list = new ArrayList<Integer>(Collections.nCopies(60, 0));

    If you want to create a list with 60 different objects, you could use the Stream API with a Supplier as follows:
    List<Person> persons = Stream.generate(Person::new)
                                 .limit(60)
                                 .collect(Collectors.toList());


111. How do I declare and initialize an array in Java?
    https://stackoverflow.com/questions/1200621/how-do-i-declare-and-initialize-an-array-in-java

    For primitive types:
    int[] myIntArray = new int[3];
    int[] myIntArray = {1,2,3};
    int[] myIntArray = new int[]{1,2,3};

    For classes, for example String, it's the same:
    String[] myStringArray = new String[3];
    String[] myStringArray = {"a","b","c"};
    String[] myStringArray = new String[]{"a","b","c"};

    The third way of initialising is useful when you declare the array first and then initialise it. Cast is necessary here.
    String[] myStringArray;
    myStringArray = new String[]{"a","b","c"};

112. Setting initial capacity to array list
    For arrays you will do, 
        int[] a = new int[5];

    Q1.
    You can set the initial size for an ArrayList by doing
        ArrayList<Integer> arr=new ArrayList<Integer>(10);
        However, you can't do
        arr.add(5, 10);

    A1.
    You're confusing the size of the array list with its capacity:
         - the size is the number of elements in the list;
         - the capacity is how many elements the list can potentially accommodate without reallocating its internal structures.
        When you call new ArrayList<Integer>(10), you are setting the list's initial capacity, not its size. In other words, when constructed in this manner, the array list starts its life empty.

    Q2.
    Is there a way of setting the size of an arraylist after declaring it?
        For example, in a traditional array, i would declare an array like this:
        int array[];

        then, i would later initialize it like this
        array = new int[1000];

        in an arraylist i am trying to do the same but I have only been able to initialize it while declaring it like below.
        ArrayList<String> array = new ArrayList<>(1000);

    A2.
    You can use ensureCapacity(int)
    ArrayList<Integer> al = new ArrayList<>();
    al.ensureCapacity(1000);

    It is important to note that array lists WILL dynamically resize themselves though.
    So I would like to know if there's a way to initialize an arraylist to for example 1000 after it's been declared in a separate statement.

    You could always do this, too:
    ArrayList<Integer> al;
    al = new ArrayList<Integer>(1000);
    
113. JAVA STREAMS
http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/

    int sum = list.stream().mapToInt(Integer::intValue).sum();
    int sum = IntStream.of(a).sum();

114. Static nested class in Java, why
https://stackoverflow.com/questions/253492/static-nested-class-in-java-why
TIJ - 4th edition

    A nested class is a member of its enclosing class. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class.

    Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.

	Top-level classes can't be declared static, only nested classes can be:
	class OuterClass {
		...
		static class StaticNestedClass {
			...
		}
		class InnerClass {
			...
		}
	}

	The difference is that:
		non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private;
		static nested classes do not have access to other members of the enclosing class.

    A nested class means:
    1. You don’t need an outer-class object inorder to create an object of a nested class
    2. You can’t access a non-static outer-class object from an object of a nested class
    Nested classes are different from ordinary inner classes in another way, as well. Fields and methods in ordinary inner classes can only be at the outer level of a class, so ordinary inner classes cannot have static data, static fields, or nested classes. However, nested classes can have all of these

    Normally, you can’t put any code inside an interface, but a nested class can be part of an interface. Any class you put inside an interface is automatically public and static. Since the class is static, it doesn’t violate the rules for interfaces—the nested class is only placed inside the namespace of the interface. You can even implement the surrounding interface in the inner class

114b. Java inner class and static nested class
https://stackoverflow.com/questions/70324/java-inner-class-and-static-nested-class

	From the Java Tutorial:
	Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are simply called static nested classes. Non-static nested classes are called inner classes.
	Static nested classes are accessed using the enclosing class name:

	OuterClass.StaticNestedClass
	For example, to create an object for the static nested class, use this syntax:

	OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
	Objects that are instances of an inner class exist within an instance of the outer class. Consider the following classes:

	class OuterClass {
		...
		class InnerClass {
			...
		}
	}
	An instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance.

	To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:

	OuterClass.InnerClass innerObject = outerObject.new InnerClass();
	see: Java Tutorial - Nested Classes

	For completeness note that there is also such a thing as an inner class without an enclosing instance:

	class A {
	  int t() { return 1; }
	  static A a =  new A() { int t() { return 2; } };
	}
	Here, new A() { ... } is an inner class defined in a static context and does not have an enclosing instance.

115. ExecutorService Shutdown
http://tutorials.jenkov.com/java-util-concurrent/executorservice.html
https://stackoverflow.com/questions/18425026/shutdown-and-awaittermination-which-first-call-have-any-difference

    When you are done using the ExecutorService you should shut it down, so the threads do not keep running.

    For instance, if your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application. The active threads inside this ExecutorService prevents the JVM from shutting down.

    To terminate the threads inside the ExecutorService you call its shutdown() method. The ExecutorService will not shut down immediately, but it will no longer accept new tasks, and once all threads have finished current tasks, the ExecutorService shuts down. All tasks submitted to the ExecutorService before shutdown() is called, are executed.

    If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method. This will attempt to stop all executing tasks right away, and skips all submitted but non-processed tasks. There are no guarantees given about the executing tasks. Perhaps they stop, perhaps the execute until the end. It is a best effort attempt.

shutdown and awaitTermination which first call have any difference?
    You should call shutdown first. Otherwise, you might be waiting for a very long time, since awaitTermination doesn't actually shut down your executor.

    If you wanted to wait for tasks to complete, rather than wait for the executor to shut down, then you should use invokeAll

116. Catch multiple exceptions
    catch (IOException | SQLException ex)

117. Concatenate strings using System.out.println
https://stackoverflow.com/questions/11035026/system-out-printlnabc32-why-output-is-abc32-and-not-abc5
    Q:
    System.out.println("abc"+3+2); // Output: abc32
    System.out.println(3+2+"abc"); //Output: 5abc

    A:
    "abc"+3
    converts 3 to a String

    "abc3"
    Then

    "abc3" + 2
    Converts 2 to a String as well

    "abc32"
    To get a numeric result do

    "abc" + (3 + 2)

118. Create array of certain size such that it can't grow beyond that
https://stackoverflow.com/questions/5196113/any-way-to-set-max-size-of-a-collection

        // In the below list "add" and "remove" won't work
        List<Integer> bl = Arrays.asList(new Integer[3]);
        // bl.add(5); // This throws UnsupportedOperationException
        bl.set(0, 6);
        bl.set(1, 7);
        bl.set(2, 8);
        // bl.set(3, 9); // This gives ArrayIndexOutOfBoundsException
 
119. How can I pass a parameter to a Java Thread
https://stackoverflow.com/questions/877096/how-can-i-pass-a-parameter-to-a-java-thread

    You need to pass the parameter in the constructor to the thread object:
        public class MyThread implements Runnable {
           public MyThread(Object parameter) {
               // store parameter for later user
           }

           public void run() {
           }
        }

    and invoke it thus:
        Runnable r = new MyThread(param_value);
        new Thread(r).start();

120. Java Blocking Queue
https://www.journaldev.com/1034/java-blockingqueue-example
http://javarevisited.blogspot.com/2012/02/producer-consumer-design-pattern-with.html

    BlockingQueue put() method will block if Queue is full in case of Bounded Queue and take() will block if Queue is empty.

    Java BlockingQueue doesn’t accept null values and throw NullPointerException if you try to store null value in the queue.
    Java BlockingQueue implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.
    Java provides several BlockingQueue implementations such as ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue etc.

121. Default Methods In Java
http://www.geeksforgeeks.org/default-methods-java/

    Java 8 introduces “Default Method” or (Defender methods) new feature, which allows developer to add new methods to the interfaces without breaking the existing implementation of these interface.
    It provides flexibility to allow interface define implementation which will use as default in the situation where a concrete class fails to provide an implementation for that method.

    Why Defaut Method?
        Reengineering an existing JDK framework is always very complex. Modify one interface in JDK framework breaks all classes that extends the interface which means that adding any new method could break millions of lines of code. Therefore, default methods have introduced as a mechanism to extending interfaces in a backward compatible way.

        Default methods can be provided to an interface without affecting implementing classes as it includes an implementation. 

        // A simple program to Test Interface default
        // methods in java
        interface TestInterface {
            // abstract method
            public void square(int a);
         
            // default method
            default void show() {
              System.out.println("Default Method Executed");
            }
        }
         
        class TestClass implements TestInterface {
            // implementation of square abstract method
            public void square(int a) {
                System.out.println(a*a);
            }
         
            public static void main(String args[]) {
                TestClass d = new TestClass();
                d.square(4);
         
                // default method executed
                d.show();
            }
        }

122. Interface with default methods vs Abstract class in Java 8
https://stackoverflow.com/questions/19998454/interface-with-default-methods-vs-abstract-class-in-java-8

    There's a lot more to abstract classes than default method implementations (such as private state), but as of Java 8, whenever you have the choice of either, you should go with the defender (aka. default) method in the interface.

    The constraint on the default method is that it can be implemented only in the terms of calls to other interface methods, with no reference to a particular implementation's state. So the main use case is higher-level and convenience methods.

    The good thing about this new feature is that, where before you were forced to use an abstract class for the convenience methods, thus constraining the implementor to single inheritance, now you can have a really clean design with just the interface and a minimum of implementation effort forced on the programmer.

    These two are quite different:
    - Default methods are to add external functionality to existing classes without changing their state.
    - And abstract classes are a normal type of inheritance, they are normal classes which are intended to be extended.
        
    There are a few technical differences. Abstract classes can still do more in comparison to Java 8 interfaces:
        Abstract class can have a constructor.
        Abstract classes are more structured and can hold a state.
    Conceptually, main purpose of defender methods is a backward compatibility after introduction of new features (as lambda-functions) in Java 8.

123. Default Method and Multiple Inheritance Ambiguity Problems
https://dzone.com/articles/interface-default-methods-java

    Since java class can implement multiple interfaces and each interface can define default method with same method signature, therefore, the inherited methods can conflict with each other.

123. Java Scanner vs BufferedReader
https://stackoverflow.com/questions/17637032/bufferedreader-vs-console-vs-scanner

    Scanner is used for parsing tokens from the contents of the stream while BufferedReader just reads the stream and does not do any special parsing.
    As to the choice, use the Scanner if you want to parse the file, use the BufferedReader if you want to read the file line by line.

    A scanner on the other hand has a lot more cheese built into it; it can do all that a BufferedReader can do and at the same level of efficiency as well. However, in addition a Scanner can parse the underlying stream for primitive types and strings using regular expressions. It can also tokenize the underlying stream with the delimiter of your choice. It can also do forward scanning of the underlying stream disregarding the delimiter!
    A scanner however is not thread safe, it has to be externally synchronized.

    Even while reading the input, if want to accept user input line by line and say just add it to a file, a BufferedReader is good enough. On the other hand if you want to accept user input as a command with multiple options, and then intend to perform different operations based on the command and options specified, a Scanner will suit better.

    BufferedReader
        Since Java 1.1
        Throws checked exceptions
        Can read chars, char arrays, and lines
        Fast

    Scanner
        Since Java 1.5
        Doesn't throw checked exceptions
        Can read lines, whitespace-delimited tokens, regex-delimited tokens, and numbers
        Difficult to read single characters

    Console
        Since Java 1.6
        Doesn't throw checked exceptions
        Can read lines
        Underlying reader can read chars and char arrays (stops at line bounds)
        Not always available (e.g. Eclipse)
        Can read passwords (i.e. read without displaying the characters)

    Recommendation: Scanner
    The methods for reading numbers are very useful. The exceptions are unchecked, so you do not have to write boilerplate try/catch blocks.

124. Scanner method to get a char
https://stackoverflow.com/questions/2597841/scanner-method-to-get-a-char/2597939#2597939

    To get a char from a Scanner, you can use the findInLine method.

        Scanner sc = new Scanner("abc");
        char ch = sc.findInLine(".").charAt(0);
        System.out.println(ch); // prints "a"
        System.out.println(sc.next()); // prints "bc"

    If you need a bunch of char from a Scanner, then it may be more convenient to (perhaps temporarily) change the delimiter to the empty string. This will make next() returns a length-1 string every time.
        Scanner sc = new Scanner("abc");
        sc.useDelimiter("");
        while (sc.hasNext()) {
            System.out.println(sc.next());
        } // prints "a", "b", "c"

125. Scanner is skipping nextLine() after using next(), nextInt() or other nextFoo()?
https://stackoverflow.com/questions/13102045/scanner-is-skipping-nextline-after-using-next-nextint-or-other-nextfoo

    That's because the Scanner.nextInt method does not consume the last newline character of your input, and thus that newline is consumed in the next call to Scanner.nextLine.

    You will encounter the similar behaviour when you use Scanner.nextLine after Scanner.next() or any Scanner.nextFoo method (except nextLine itself).

    Workaround:
        Either fire a blank Scanner.nextLine call after Scanner.nextInt or Scanner.nextFoo to consume rest of that line including newline
            int option = input.nextInt();
            input.nextLine();  // Consume newline left-over
            String str1 = input.nextLine();

        Or, it would be even better, if you read the input through Scanner.nextLine and convert your input to the proper format you need. For examples, to an integer using Integer.parseInt(String) method.
            int option = 0;
            try {
                option = Integer.parseInt(input.nextLine());
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
            String str1 = input.nextLine();

126. Read array using Scanner and BufferedReader
https://stackoverflow.com/questions/14635136/read-integers-separated-with-whitespace-into-int-array

You could use Scanner:
    Scanner scanner = new Scanner(System.in);
    List<Integer> list = new ArrayList<Integer>();
    while (scanner.hasNextInt())
      list.add(scanner.nextInt());
    int[] arr = list.toArray(new int[0]);

BufferedReader is Faster then Scanner
    Using BufferedReader and then splitting and parsing each Integer value is much Faster then using nextInt() method of Scanner.

        BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));
        int num[] = new int[1000];
        String[] strNums;    
        strNums = bi.readLine().split("\\s");
        for(int i=0; i<strNums.length; i++) {
            num[i] = Integer.parseInt(strNums[i]);
        }

127. Read multiple lines from console

        List<String> lines = new ArrayList<>();
        Scanner s = new Scanner(System.in);
        while (s.hasNextLine()) {
            String line = s.nextLine();
            if (line.isEmpty()) {
                break;
            }
            lines.add(line);
        }

128a. Find index of String in another string
    String.indexOf(String str)
    Boolean found = text.contains(word);

128b. Get substring from String / StringBuilder
    line.substring(line.indexOf("//") + 1);
    String substring(int beginIndex, int endIndex)
        Returns a new string that is a substring of this string. The substring begins at the specified beginIndex and extends to the character at index endIndex - 1

128c. Java indexOf method for multiple matches in String
    i = str.indexOf('x');
    while(i >= 0) {
         System.out.println(i);
         i = str.indexOf('x', i+1);
    }

129. How can I clear or empty a StringBuilder?
    stringBuilderObj.setLength(0)

130. What is the best way to tell if a character is a letter or number in Java without using regexes?
    private static boolean isLetterOrDigit(char c) {
        return (c >= 'a' && c <= 'z') ||
               (c >= 'A' && c <= 'Z') ||
               (c >= '0' && c <= '9');
    }

131. How to match letters only using java regex, matches method?
    String s = "abcdefà";
    Pattern p = Pattern.compile("[^a-zA-Z0-9]");
    boolean hasSpecialChar = p.matcher(s).find();

132. Don't assign one list to another
    If you do, then modifying one list will modify another list too

    1.
    ArrayList<String> newArrayList = (ArrayList<String>) oldArrayList.clone();

    2.
    List<String> strs;
    ...
    List<String> newStrs = new ArrayList<>(strs);

    3.
    List<String> list2 = list1.stream().collect(Collectors.toList());

133. How to sort Map values by key in Java
https://stackoverflow.com/questions/922528/how-to-sort-map-values-by-key-in-java

    Use a TreeMap. This is precisely what its for.

    Remember when using a TreeMap or TreeSet that it will have different performance characteristics than HashMap or HashSet. Roughly speaking operations that find or insert an element will go from O(1) to O(Log(N)).

    Assuming TreeMap is not good for you (and assuming you can't use generics):
        List sortedKeys=new ArrayList(yourMap.keySet());
        Collections.sort(sortedKeys);
        // Do what you need with sortedKeys.

134. Arrays.fill with multidimensional array in Java
    // Fill each row with 1.0
    for (double[] row: matrix)
        Arrays.fill(row, 1.0);

135. Implement Comparator function
https://stackoverflow.com/questions/5805602/how-to-sort-list-of-objects-by-some-property
        Collections.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval a, Interval b) {
                return a.start > b.start ? 1 : a.start < b.start ? -1 : 0;
            }
        });

    Either make ActiveAlarm implement Comparable<ActiveAlarm> or implement Comparator<ActiveAlarm> in a separate class. Then call:
        Collections.sort(list);
    or
        Collections.sort(list, comparator);

    In general, it's a good idea to implement Comparable<T> if there's a single "natural" sort order... otherwise (if you happen to want to sort in a particular order, but might equally easily want a different one) it's better to implement Comparator<T>. This particular situation could go either way, to be honest... but I'd probably stick with the more flexible Comparator<T> option

136. Possible Lossy conversion from long to int
    Array index is an integer in Java and the compiler will advice you. So maximum array size is (aproximately) Integer.MAX_VALUE. For bigger arrays you should use ArrayList.

137. How do I convert from int to Long in Java?
    Note that there is a difference between a cast to long and a cast to Long. If you cast to long (a primitive value) then it should be automatically boxed to a Long (the reference type that wraps it)

    Long.valueOf(int);

138. Do containsAll() and retainAll() in the Collection interface address cardinality?
    No

    Using containsAll(). This option is not ideal, in my opinion, because it offers worst case performance, O(n^2).

    There are two variations to this:
    2a) If you don't care about maintaining the order ofyour lists... use Collections.sort() on both list. Then use the equals(). This is O(nlogn), because you do two sorts, and then an O(n) comparison.

139. Simple way to find if two different lists contain exactly the same elements?
    If you care about order, then just use the equals method:
        list1.equals(list2)

140. CompareTo with primitives -> Integer / int
    Integer.compare(int, int)

    int cmp = a > b ? +1 : a < b ? -1 : 0;

140. Java: is there an easy way to select a subset of an array?
    Arrays.copyOfRange(array, 1, array.length);

141. Initialization of an ArrayList in one line
    Actually, probably the "best" way to initialize the ArrayList is the method you wrote, as it does not need to create a new List in any way:
        ArrayList<String> list = new ArrayList<String>();
        list.add("A");
        list.add("B");
        list.add("C");

142. How to convert int[] into List<Integer> in Java?

    There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> which is not what you want. You have to make a utility method.

        int[] ints = {1, 2, 3};
        List<Integer> intList = new ArrayList<Integer>();
        for (int index = 0; index < ints.length; index++)
        {
            intList.add(ints[index]);
        }


    Actually, probably the "best" way to initialize the ArrayList is the method you wrote, as it does not need to create a new List in any way:
        ArrayList<String> list = new ArrayList<String>();
        list.add("A");
        list.add("B");
        list.add("C");

143. How to set a default value for items list / array?

    Integer[] integers = new Integer[10];
    Arrays.fill(integers, 0);

    Collections.nCopies is your friend if you need a list instead of an array:
        List<Integer> list = Collections.nCopies(10, 0);
    If a mutable list is needed, wrap it:
        List<Integer> list = new ArrayList<>(Collections.nCopies(10, 0));

144. Get Size of data types
    Since Java 8, all wrapper classes of primitive types (except Boolean) have a BYTES field
        Double.BYTES 
        Integer.BYTES

    Pre Java 8 - Get size in bits and conver to bytes
        Double.SIZE / Byte.SIZE
        Integer.SIZE / Byte.SIZE

145. Remove last character from String and StringBuilder
    sb.setLength(sb.length() - 1);
    str = str.substring(0, str.length() - 1);

146. Convert int to int array
        String temp = Integer.toString(guess);
        int[] newGuess = new int[temp.length()];
        for (int i = 0; i < temp.length(); i++)
        {
            newGuess[i] = temp.charAt(i) - '0';
        }

147. Change char in a StringBuilder
    setCharAt()

148. String equals
    == tests for reference equality (whether they are the same object).
    .equals() tests for value equality (whether they are logically "equal").

149. String.charAt() goes out of bound if index is beyond string length

150. How to initialize HashSet values by construction?
    Set<String> h = new HashSet<>(Arrays.asList("a", "b"));
    Again, this is not time efficient since you are constructing an array, converting to a list and using that list to create a set

    Set<String> h = new HashSet<String>() {{
        add("a");
        add("b");
    }};

    Set<String> set = Stream.of("a", "b").collect(Collectors.toSet());

151. List of lists
https://stackoverflow.com/questions/12861726/why-cant-you-have-a-listliststring-in-java
    List<List<Integer>> lists = new ArrayList<List<Integer>>();

152. Directly return an array
    return new int[]{start, start+dur}
    return new int[]{}

153. Remove range of elements from a list
    list.subList(start, end).clear();
    This actually calls removeRange behind the scenes

    List<Integer> head = numbers.subList(0, 4);
    List<Integer> tail = numbers.subList(4, 8);

154. Int to Char and Char to int
https://stackoverflow.com/questions/17984975/convert-int-to-char-in-java
    int a = 1;
    char b = (char) a;
    System.out.println(b);

    will print out the char with ascii value 1 (start-of-heading char, which isn't printable).

    int a = '1';
    char b = (char) a;
    System.out.println(b);

    will print out the char with ascii value 49 (one corresponding to '1')

    If you want to convert a digit (0-9), you can add 48 to it and cast, or something like Character.forDigit(a, 10);.

https://stackoverflow.com/questions/16458564/convert-character-to-ascii-numeric-value-in-java
    char character = name.charAt(0); // This gives the character 'a'
    int ascii = (int) character; // ascii is now 97.

    Though cast is not required explicitly, but its improves readability.

    int ascii = character; // Even this will do the trick.

155. Convert HashSet to List
    List<String> list = new ArrayList<String>(listOfTopicAuthors);

    Also,
    mainList.addAll(set);

156. String to Uppercase (Upper case) and lowercase (lower case)
    inputVal.toUpperCase()
    inputVal.toLowerCase()

157. Count number of digits in a number
    int length = (int)(Math.log10(n)+1);
    int length = String.valueOf(1000).length();

157b. Log base2 in Java
    Math.log10(value) / Math.log10(2)

158. Remove duplicate lists using Collection
https://stackoverflow.com/questions/42330457/using-collection-to-remove-duplicate-lists
    List<Integer> coins1 = Arrays.asList(5, 5, 10);
    List<Integer> coins2 = Arrays.asList(5, 10, 5);
    List<Integer> coins3 = Arrays.asList(10, 10);

    Set<Integer> dedupedCollection = new HashSet<Integer>();

    dedupedCollection.add(coins1);
    dedupedCollection.add(coins2);
    dedupedCollection.add(coins3);

    return dedupedCollection;

159. Java Arrays how to add elements at the beginning
    list.add(0, yourObject);

160. Create a compareTo to a Generic Class that Implements Comparable
    public class DoubleKey<K extends Comparable<K>, J extends Comparable<J>> implements Comparable<DoubleKey<K, J>> {

        private K key1;
        private J key2;

        public DoubleKey(K key1, J key2) {
            this.key1 = key1;
            this.key2 = key2;
        }

        public K getFirstKey() {
            return this.key1;
        }

        public J getSecondKey() {
            return this.key2;
        }

        public int compareTo(DoubleKey<K, J> that) {

            int cmp = this.getFirstKey().compareTo(that.getFirstKey());
            if (cmp == 0)
                cmp = this.getSecondKey().compareTo(that.getSecondKey());
            return cmp;
        }
    }

161. Java- The meaning of <T extends Comparable<T>>?
    The full context being:
        public class RClass<T extends Comparable<T>>
    Would I be right in saying that the statement in the title means that the arguments plugged into the method must either be an object of a class which implements Comparable OR one of its derived classes?

    This means that the type parameter must support comparison with other instances of its own type, via the Comparable interface.

    An example of such a class is provided in the Oracle tutorial Object Ordering. Note the similar pattern to T extends Comparable<T> in the excerpt below:

    public class Name implements Comparable<Name> {
       ...
       public int compareTo(Name n) { ... }
    }

162. Get first / last element from LinkedHashMap and LinkedHashSet
    Get first:
        1.
        Object key = linkedHashMap.keySet().iterator().next();

        2.
        for(String aSiteId: siteIdSet) {
            siteId = aSiteId;
            break;
        }

    Get Last:
        1. This take O(1) space and O(n) time
        while (iterator.hasNext()) { lastElement = iterator.next() }

        2. This take O(n) space and O(n) time
        linkedHashMap.entrySet().toArray()[linkedHashMap.size() -1];

163. What's the difference between ConcurrentHashMap and Collections.synchronizedMap(Map)?
https://stackoverflow.com/questions/510632/whats-the-difference-between-concurrenthashmap-and-collections-synchronizedmap

    ConcurrentHashMap does not allow null keys or values. So they are NOT equal alternatives of a synchronized map

    For your needs, use ConcurrentHashMap. It allows concurrent modification of the Map from several threads without the need to block them. Collections.synchronizedMap(map) creates a blocking Map which will degrade performance, albeit ensure consistency (if used properly).

    Use the second option if you need to ensure data consistency, and each thread needs to have an up-to-date view of the map. Use the first if performance is critical, and each thread only inserts data to the map, with reads happening less frequently

    ╔═══════════════╦═══════════════════╦═══════════════════╦═════════════════════╗
    ║   Property    ║     HashMap       ║    Hashtable      ║  ConcurrentHashMap  ║
    ╠═══════════════╬═══════════════════╬═══════════════════╩═════════════════════╣ 
    ║      Null     ║     allowed       ║              not allowed                ║
    ║  values/keys  ║                   ║                                         ║
    ╠═══════════════╬═══════════════════╬═════════════════════════════════════════╣
    ║Is thread-safe ║       no          ║                  yes                    ║
    ╠═══════════════╬═══════════════════╬═══════════════════╦═════════════════════╣
    ║     Lock      ║       not         ║ locks the whole   ║ locks the portion   ║        
    ║  mechanism    ║    applicable     ║       map         ║                     ║ 
    ╠═══════════════╬═══════════════════╩═══════════════════╬═════════════════════╣
    ║   Iterator    ║               fail-fast               ║ weakly consistent   ║ 
    ╚═══════════════╩═══════════════════════════════════════╩═════════════════════╝

    Regarding locking mechanism: Hashtable locks the object, while ConcurrentHashMap locks only the bucket.

164. Java Fastest way to read through text file with 2 million lines
https://stackoverflow.com/questions/19486077/java-fastest-way-to-read-through-text-file-with-2-million-lines

    You will find that BufferedReader.readLine() is as fast as you need: you can read millions of lines a second with it. It is more probable that your string splitting and handling is causing whatever performance problems you are encountering.

164. Find indexOf a byte array within another byte array

    Google's Guava provides a Bytes.indexOf(byte[] array, byte[] target).

    The simpelst way would be to compare each element:
    public int indexOf(byte[] outerArray, byte[] smallerArray) {
        for(int i = 0; i < outerArray.length - smallerArray.length+1; ++i) {
            boolean found = true;
            for(int j = 0; j < smallerArray.length; ++j) {
               if (outerArray[i+j] != smallerArray[j]) {
                   found = false;
                   break;
               }
            }
            if (found) return i;
         }
       return -1;  
    }  

165. Find an array inside another larger array
    public static int findArray(Integer[] array, Integer[] subArray)
    {
        return Collections.indexOfSubList(Arrays.asList(array), Arrays.asList(subArray));
    }

166. File to byte[] in Java
    Path path = Paths.get("path/to/file");
    byte[] data = Files.readAllBytes(path);

167. How can the wait() and notify() methods be called on Objects that are not threads?
https://stackoverflow.com/questions/16197135/how-can-the-wait-and-notify-methods-be-called-on-objects-that-are-not-thread

    Locks are different from threads. The lock is on the data structure being protected. The threads are the things accessing the data structure. The locks are on the data structure object in order to keep the threads from accessing the data structure in an unsafe way.

    Any object can be used as an intrinsic lock (meaning used in conjunction with synchronized). This way you can guard access to any object by adding the synchronized modifier to the methods that access the shared data. (Not that it's a good idea, because that allows any thread that can access the object to acquire its lock, even if it's not calling any methods on it; it's better to keep the lock as a private member of the data structure being locked, so that access to it is limited.)

    wait and notify are called on objects that are being used as locks. The lock is a shared communication point:

    When a thread that has a lock calls notifyAll on it, the other threads waiting on that same lock get notified. When a thread that has a lock calls notify on it, one of the threads waiting on that same lock gets notified.

    When a thread that has a lock calls wait on it, the thread releases the lock and goes dormant until either a) it receives a notification, or b) it just wakes up arbitrarily (the "spurious wakeup"); the waiting thread remains stuck in the call to wait until it wakes up due to one of these 2 reasons, then the thread has to re-acquire the lock before it can exit the wait method

168. Multithreading - Counting total amount of words from several files
https://stackoverflow.com/questions/8438497/multithreading-counting-total-amount-of-words-from-several-files
https://stackoverflow.com/questions/24133037/java-wordcount-a-mediocre-implementation
https://softwareengineering.stackexchange.com/questions/337225/parsing-multiple-files-and-their-contents-in-java-using-multithreading-without-e
    A worker thread:
        class WordCount extends Thread {
           int count;

           @Override
           public void run() {
              count = 0;
              /* Count the words... */
              ...
              ++count;
              ...
           }
        }

    And a class to use them:
        class Main {
           public static void main(String args[]) throws InterruptedException {
              WordCount[] counters = new WordCount[args.length];
              for (int idx = 0; idx < args.length; ++idx) {
                 counters[idx] = new WordCount(args[idx]);
                 counters[idx].start();
              }
              int total = 0;
              for (WordCount counter : counters) {
                counter.join();
                total += counter.count;
              }
              System.out.println("Total: " + total);
           }
        }

169. Deep, Shallow and Lazy Copy with Java Examples
https://www.geeksforgeeks.org/deep-shallow-lazy-copy-java-examples/
https://stackoverflow.com/questions/13667556/shallow-copy-new-instance-or-assignment

    Just doing the assignment of reference just creates a copy of reference which points to the same instance.

    But generally I prefer two ways: -

    Either use a copy-constructor: -
        public A(A obj) {
            copy.aValue = obj.aValue;
        }
    And use it like: -
        A first = new A();
        A copy = new A(first);

    Or, use a public static method which takes an instance and returns a copy of that.
        public static A createCopy(A obj) {
            A copy = new A();
            copy.aValue = obj.aValue;
            return copy;
        }

    - Whenever we use default implementation of clone method we get shallow copy of object means it creates new instance and copies all the field of object to that new instance and returns it as object type
    - Whenever we need own copy not to use default implementation we call it as deep copy

    Lazy Copy
    A lazy copy can be defined as a combination of both shallow copy and deep copy. The mechanism follows a simple approach – at the initial state, shallow copy approach is used. A counter is also used to keep a track on how many objects share the data. When the program wants to modify the original object, it checks whether the object is shared or not. If the object is shared, then the deep copy mechanism is initiated.

170. How to merge more than one hashmaps also sum the values of same key in java
    m2.forEach((k, v) -> m.merge(k, v, (v1, v2) -> v1 + v2));

171. Access private method from outside the class
https://stackoverflow.com/questions/11282265/how-to-call-a-private-method-from-outside-a-java-class

    use setAccessible(true) on your Method object before using its invoke method.
        import java.lang.reflect.*;
        class Dummy{
            private void foo(){
                System.out.println("hello foo()");
            }
        }

        class Test{
            public static void main(String[] args) throws Exception {
                Dummy d = new Dummy();
                Method m = Dummy.class.getDeclaredMethod("foo");
                //m.invoke(d);// throws java.lang.IllegalAccessException
                m.setAccessible(true);// Abracadabra 
                m.invoke(d);// now its OK
            }
        }

172. Java 7 vs Java 8
http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html
    Lambda expressions
    Parallel operations
    Java + JavaScript = ❤
    New date / time APIs
    Concurrent accumulators

173. Should I initialize variable within constructor or outside constructor [duplicate]
    public class ME {
        private int i;

        public ME() {
             this.i = 100;
        }
    }

    public class ME {
        private int i = 100;

        public ME() {
        }
    }

    I find the second style (declaration + initialization in one go) superior. Reasons:
    It makes it clear at a glance how the variable is initialized. Typically, when reading a program and coming across a variable, you'll first go to its declaration (often automatic in IDEs). With style 2, you see the default value right away. With style 1, you need to look at the constructor as well.

    As to the concern mentioned above about multiple constructors, that's easily solved by having one no-arg constructor that initializes all the instance variables that are initilized the same for all constructors and then each constructor calls this() at the first line.

174. How to create a generic array in Java?
https://stackoverflow.com/questions/529085/how-to-create-a-generic-array-in-java
https://stackoverflow.com/questions/2927391/whats-the-reason-i-cant-create-generic-array-types-in-java

        queue = (T[])new Object[capacity];

    The below still gives ArrayStoreException
        public class GenSet<E> {
            private E a[];

            public GenSet() {
                a = new E[INITIAL_ARRAY_LENGTH]; // error: generic array creation
            }

            public GenSet(Class<E[]> clazz, int length) {  
                a = clazz.cast(Array.newInstance(clazz.getComponentType(), length));  
            }  
        }

        class Stack<T> {
            public Stack(Class<T> clazz, int capacity) {
                array = (T[])Array.newInstance(clazz, capacity);
            }

            private final T[] array;
        }

        GenSet<String> foo = new GenSet<String>(String[].class, 1);  

172. Java Queue LinkedList vs ArrayDeque
https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist

    Linked structures are possibly the worst structure to iterate with a cache miss on each element. On top of it they consume way more memory.

    If you need add/remove of the both ends, ArrayDeque is significantly better than a linked list. Random access each element is also O(1) for a cyclic queue.

    It's "better" in some cases because you're not allocating a node for each item to insert; instead all elements are stored in a giant array, which is resized if it gets full.

173. Remove element from Array
https://stackoverflow.com/questions/7940337/remove-a-specific-string-from-an-array-of-string
    Arrays are fixed length and can not be resized once created. You can set an element to null to remove an object reference;

174. why is Stack a class while Queue is a Interface?

    Stack, is a Last-In-First-Out stack of objects derived from Vector, also a class. Vector goes with the "old" set of collections that Java originally shipped with, and derives ultimately from AbstractCollection. Of note, there's really one canonical implementation of a Stack; Queues and Lists have many well known implementations that can make a substantial performance difference when chosen correctly.

    Queue on the other hand follows the Collection interface from the "new" set of collections that are typically used today, so it follows the interfaces and comes with a variety of implementations.

    Stacks should be used when you need LIFO semantics, while Queues should be used when you need First-In-First-Out semantics.

    ArrayList and LinkedList store ordered collections of things, and don't line up with the use-cases of Stack or Queue directly. Stacks and Queues are in a sense buffers of data, whereas the semantics of a List typically make it such that it's a store of data; nothing is stopping you from using a List to implement a Stack or a Queue

175. Call constructor from main AND initialize array in constructor with capacity
    public class ArrayConstructorDeclaration {
        int[] arr;

        public ArrayConstructorDeclaration(int capacity) {
            arr = new int[capacity];
        }

        public static void main(String[] args) {
            ArrayConstructorDeclaration ob = new ArrayConstructorDeclaration(5);
            System.out.println(Arrays.toString(ob.arr));
        }
    }

176. Java Options class
https://commons.apache.org/proper/commons-cli/javadocs/api-1.3.1/org/apache/commons/cli/Options.html

177. What is the difference between “Class.forName()” and “Class.forName().newInstance()”?

    Maybe an example demonstrating how both methods are used will help you to understand things better. So, consider the following class:
        package test;
        public class Demo {
            public Demo() {
                System.out.println("Hi!");
            }

            public static void main(String[] args) throws Exception {
                Class clazz = Class.forName("test.Demo");
                Demo demo = (Demo) clazz.newInstance();
            }
        }

    As explained in its javadoc, calling Class.forName(String) returns the Class object associated with the class or interface with the given string name i.e. it returns test.Demo.class which is affected to the clazz variable of type Class.

    Then, calling clazz.newInstance() creates a new instance of the class represented by this Class object. The class is instantiated as if by a new expression with an empty argument list. In other words, this is here actually equivalent to a new Demo() and returns a new instance of Demo.

    And running this Demo class thus prints the following output:
        Hi!
    The big difference with the traditional new is that newInstance allows to instantiate a class that you don't know until runtime, making your code more dynamic.

178. In Eclipse, can I have multiple Console views at once, each showing a different Console?
https://stackoverflow.com/questions/7261151/in-eclipse-can-i-have-multiple-console-views-at-once-each-showing-a-different

Yes,

    located near your console tab should be a button "Open Console".
    If you click this button one of your options should be "New Console View".

179. What is the difference between System.getProperty and properties.getProperty in Java
https://stackoverflow.com/questions/17151547/what-is-the-difference-between-system-getproperty-and-properties-getproperty-in

180. Using Java System Properties
https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html

    In Properties, we examined the way an application can use Properties objects to maintain its configuration. The Java platform itself uses a Properties object to maintain its own configuration. The System class maintains a Properties object that describes the configuration of the current working environment. System properties include information about the current user, the current version of the Java runtime, and the character used to separate components of a file path name.

181. Difference between System.getenv() & System.getProperty() [duplicate]
https://stackoverflow.com/questions/13112038/difference-between-system-getenv-system-getproperty

182. Finding enum value with Java 8 Stream API
https://stackoverflow.com/questions/27807232/finding-enum-value-with-java-8-stream-api

    return Arrays.stream(Type.values())
                .filter(e -> e.s.equals(val))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException(String.format("Unsupported type %s.", val)));

183. Static Initialization Blocks
https://stackoverflow.com/questions/2420389/static-initialization-blocks/2420404#2420404
https://stackoverflow.com/questions/12550135/static-block-vs-initializer-block-in-java

Here's an example:

  private static final HashMap<String, String> MAP = new HashMap<String, String>();
  static {
    MAP.put("banana", "honey");
    MAP.put("peanut butter", "jelly");
    MAP.put("rice", "beans");
  }
The code in the "static" section(s) will be executed at class load time, before any instances of the class are constructed (and before any static methods are called from elsewhere). That way you can make sure that the class resources are all ready to use.

They're for two very different purposes:

The static initializer block will be called on loading of the class, and will have no access to instance variables or methods. As per @Prahalad Deshpande's comment, it is often used to create static variables.
The non-static initializer block on the other hand is created on object construction only, will have access to instance variables and methods, and (as per the important correction suggested by @EJP) will be called at the beginning of the constructor, after the super constructor has been called (either explicitly or implicitly) and before any other subsequent constructor code is called. 

184. GROOVY:
https://www.tutorialspoint.com/groovy/groovy_methods.htm

185. JsonMappingException: No suitable constructor found for type [simple type, class ]: can not instantiate from JSON object
https://stackoverflow.com/questions/7625783/jsonmappingexception-no-suitable-constructor-found-for-type-simple-type-class

186. Why Objects should be immutable
https://octoperf.com/blog/2016/04/07/why-objects-must-be-immutable/

187. How to create default constructor for immutable class
https://stackoverflow.com/questions/52437320/how-to-create-default-counstructor-for-immutable-class

    class School {
        //fields

        public School(String id, String name) {
            this.schoolId = id;
            this.schoolName = name;
        }

        @JsonCreator
        public static School create(Map<String, Object> object) {
            return new School((String) object.get("schoolId"),
                              (String) object.get("schoolName"));
        }

        //getters
    }

188. Using Executor Service and Thread
            Executor.execute(() -> {
                // line or method;
            });

            new Thread(() -> {
                myBundle.setCurrentFloorPlan(0);
            }).start();

189. Making local variables and parameters as final
https://stackoverflow.com/questions/316352/why-would-one-mark-local-variables-and-method-parameters-as-final-in-java

190. Mockito test a void method throws an exception
https://stackoverflow.com/questions/15156857/mockito-test-a-void-method-throws-an-exception/15157021

191. Test coverage to private constructor
https://stackoverflow.com/questions/4520216/how-to-add-test-coverage-to-a-private-constructor

192. Static import in Java
    Difference between import and static import
        With the help of import, we are able to access classes and interfaces which are present in any package. But using static import, we can access all the static members (variables and methods) of a class directly without explicitly calling class name.
        For Example: we always use sqrt() method of Math class by using Math class i.e. Math.sqrt(), but by using static import we can access sqrt() method directly.

        The main difference is Readablity, ClassName.dataMember (System.out) is less readable when compared to dataMember(out), static import can make your program more readable

193. Dependency Injection
https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f
http://www.vogella.com/tutorials/DependencyInjection/article.html

194. Argument Captor
https://stackoverflow.com/questions/36253040/example-on-mockitos-argumentcaptor

195. AssertEquals and AssertSame
https://stackoverflow.com/questions/28451925/why-assertequals-and-assertsame-in-junit-return-the-same-result-for-two-instance

196. RxJava
http://www.vogella.com/tutorials/RxJava/article.html
https://medium.com/@factoryhr/understanding-java-rxjava-for-beginners-5eacb8de12ca
https://blog.mindorks.com/rxjava-anatomy-what-is-rxjava-how-rxjava-is-designed-and-how-rxjava-works-d357b3aca586
https://www.baeldung.com/rxjava-schedulers
https://medium.com/@vanniktech/rxjava-2-disposable-under-the-hood-f842d2373e64

197:
How to tell Jackson to ignore a field during serialization if its value is null?
https://stackoverflow.com/questions/11757487/how-to-tell-jackson-to-ignore-a-field-during-serialization-if-its-value-is-null

    To suppress serializing properties with null values using Jackson >2.0, you can configure the ObjectMapper directly, or make use of the @JsonInclude annotation:

    mapper.setSerializationInclusion(Include.NON_NULL);
    or:

    @JsonInclude(Include.NON_NULL)
    class Foo
    {
      String bar;
    }

198:
Ignoring new fields on JSON objects using Jackson [duplicate]
https://stackoverflow.com/questions/5455014/ignoring-new-fields-on-json-objects-using-jackson

    Jackson provides an annotation that can be used on class level (JsonIgnoreProperties).

    Add the following to the top of your class (not to individual methods):

    @JsonIgnoreProperties(ignoreUnknown = true)
    public class Foo {
        ...
    }

199.
Why is “log and throw” considered an anti-pattern? [closed]
https://stackoverflow.com/questions/6639963/why-is-log-and-throw-considered-an-anti-pattern

    I assume the answer is largely because why are you catching it if you can't handle it? Why not let whomever can handle it (or whomever is left with no choice but to handle it) log it, if they feel that it is log-worthy?

    If you catch it and log it and rethrow it, then there's no way for the upstream code to know that you've already logged the exception, and so the same exception might get logged twice. Or worse, if all the upstream code follows this same pattern, the exception might be logged an arbitrary number of times, once for each level in the code that decides to catch it, log it, and then throw it again.

    Also some might argue that since throwing and catching exceptions are relatively costly operations, all this catching and rethrowing isn't helping your runtime performance. Nor is it helping your code in terms of conciseness or maintainability.


    Log-and-throw is a good pattern iff the entity catching and rethrowing the exception has reason to believe that it contains information which will not get logged further up the call stack--at least not in the most-desired fashion. A couple of reasons this may occur:

    The exception may be caught and rethrown at an application-layer boundary, and may contain privileged information. It would be bad for a database layer to allow an exception saying, e.g. "Attempt to add duplicate key 'fnord' to field 'users'" to reach the outer application layer (which might in turn expose it to a user), but it could be useful for inner portions of the database to throw such an exception and the application interface to catch it, log it securely, and rethrow a somewhat less descriptive exception.
    The exception may be one that the outer layer would likely be expecting to handle without logging, but the inner layer may know something that the outer layer doesn't which would suggest that logging may be useful. As a crude example, a middle application layer might be programmed to try connecting to one server and, if that doesn't work, try another. Flooding the application's log with 'connection failed' messages while a server is down for maintenance might not be helpful, especially since--from the application's perspective, everything worked fine. It may be useful to forward information about the connection failure to a logging resource associated with servers, which could then filter the logs so as to produce a report of when the server went up and down, as opposed to a log of every single connection attempt.

200.
How convert byte array to string [duplicate]
https://stackoverflow.com/questions/11654562/how-convert-byte-array-to-string

    var str = System.Text.Encoding.Default.GetString(result);

    string convert = "This is the string to be converted";

    // From string to byte array
    byte[] buffer = System.Text.Encoding.UTF8.GetBytes(convert);

    // From byte array to string
    string s = System.Text.Encoding.UTF8.GetString(buffer, 0, buffer.Length);

201.
How to check which exception type was thrown in Java?
https://stackoverflow.com/questions/27280928/how-to-check-which-exception-type-was-thrown-in-java

    if (e instanceof NotAnInt) {
        ...
    }

193. Java 8 Function
https://dzone.com/articles/functional-programming-java-8

    x -> x + 1
    And what is the type of this function in Java?

    Well, the answer is that it depends. In Java the same lambda expression could be bound to variables of different types. For instance, the following two are valid declarations in Java:

    Function<Integer,Integer> add1 = x -> x + 1;
    Function<String,String> concat = x -> x + 1;
    The first one increments an integer x by one, whereas the second one concatenates the integer 1 to any string x.

    And how can we invoke these functions?

    Well, now that they are bound to a reference we can treat them pretty much like we treat any object:

    Integer two = add1.apply(1); //yields 2
    String answer = concat1.apply("0 + 1 = "); //yields "0 + 1 = 1"

194. Java STREAMS
    durableGeometryIds.addAll(durablePolygons.stream().map(DurableGeometry::getId).collect(Collectors.toList()));
    durablePoses.stream().map(DurableGeometry::getId).forEach(durableGeometryIds::add)

195. Get first element of HashSet
https://stackoverflow.com/questions/8882295/how-to-get-the-first-element-of-the-list-or-set

    set.iterator().next();

196. Iterate through HashSet
https://stackoverflow.com/questions/12455737/how-to-iterate-over-a-set-hashset-without-an-iterator

1.
    Set<String> set = new HashSet<String>();

    //populate set

    for (String s : set) {
        System.out.println(s);
    }

2.
    set.forEach(System.out::println);

3.
    Iterator iter = set.iterator();
    while (iter.hasNext()) {
        System.out.println(iter.next());
    }

197. Java 8 stream operation on empty list
I am just wondering what will be behavior of Java 8 stream on empty list.

List<?> emptyList = new ArrayList<>();
List<?> processedList = emptyList.stream().collect(Collectors.toList());

https://stackoverflow.com/questions/54501501/java-8-stream-operation-on-empty-list/54501749

    collect is a terminal operation, so it must be evaluated.

    When terminating a Stream pipeline with collect(Collectors.toList()), you'll always get an output List (you'll never get null). If the Stream is empty (and it doesn't matter if it's empty due to the source of the stream being empty, or due to all the elements of the stream being filtered out prior to the terminal operation), the output List will be empty too.

198. Java Platform Independent
https://www.geeksforgeeks.org/java-platform-independent/
https://www.geeksforgeeks.org/how-does-a-c-program-executes/
https://www.geeksforgeeks.org/compilation-execution-java-program/
https://stackoverflow.com/questions/7674839/is-the-jvm-a-compiler-or-an-interpreter    
    Javac is Java Compiler -- Compiles your Java code into Bytecode

    JVM is Java Virtual Machine -- Runs/ Interprets/ translates Bytecode into Native Machine Code

    JIT is Just In Time Compiler -- Compiles the given bytecode instruction sequence to machine code at runtime before executing it natively. It's main purpose is to do heavy optimizations in performance.

    So now, Let's find answers to your questions..

    1)JVM: is it a compiler or an interpreter? -- Ans: Interpreter

    2)what about JIT compiler that exist inside the JVM? -- Ans: If you read this reply completly, you probably know it now


    Java compiler produces a unique type of code called bytecode unlike c compiler where compiler produces only natively executable code for a particular machine.
    When the Java program runs in a particular machine it is sent to java compiler, which converts this code into intermediate code called bytecode. This bytecode is sent to Java virtual machine (JVM) which resides in the RAM of any operating system. JVM recognizes the platform it is on and converts the bytecodes into native machine code. Hence java is called platform independent language.

199. Functional Interfaces and Lamda Expressions
Functional Interfaces: What is Functional Interface?
    If a Java interface contains one and only one abstract method then it is termed as functional interface. This only one method specifies the intended purpose of the interface.

    For example, the Runnable interface from package java.lang; is a functional interface because it constitutes only one method i.e. run().

    Example 1: Define a Functional Interface in java
        import java.lang.FunctionalInterface;
        @FunctionalInterface
        public interface MyInterface{
            // the single abstract method
            double getValue();
        }

    In Java 7, functional interfaces were considered as Single Abstract Methods or SAM type. SAMs were commonly implemented with Anonymous Classes in Java 7.

    Example 2: Implement SAM with anonymous classes in java
        public class FunctionInterfaceTest {
            public static void main(String[] args) {

                // anonymous class
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("I just implemented the Runnable Functional Interface.");
                    }
                }).start();
            }
        }

Introduction to lambda expressions
Lambda expression is, essentially, an anonymous or unnamed method. The lambda expression does not execute on its own. Instead, it is used to implement a method defined by a functional interface.

How to define lambda expression in Java?
Here is how we can define lambda expression in Java.

(parameter list) -> lambda body
The new operator (->) used is known as an arrow operator or a lambda operator. The syntax might not be clear at the moment. Let's explore some examples,

Suppose, we have a method like this:

double getPiValue() {
    return 3.1415;
}
We can write this method using lambda expression as:

() -> 3.1415
Here, the method does not have any parameters. Hence, the left side of the operator includes an empty parameter. The right side is the lambda body that specifies the action of the lambda expression. In this case, it returns the value 3.1415.

Types of Lambda Body
In Java, the lambda body is of two types.

1. A body with a single expression

() -> System.out.println("Lambdas are great");
This type of lambda body is known as the expression body.

2. A body that consists of a block of code.

() -> {
    double pi = 3.1415;
    return pi;
};
This type of the lambda body is known as a block body. The block body allows the lambda body to include multiple statements. These statements are enclosed inside the braces and you have to add a semi-colon after the braces.

Note: For the block body, you should always have a return statement. However, the expression body does not require a return statement.
200. Java Streams Continued
https://winterbe.com/posts/2014/03/16/java-8-tutorial/

1. Using Lambda Expressions for Sorting

Let's start with a simple example of how to sort a list of strings in prior versions of Java:

    List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");

    Collections.sort(names, new Comparator<String>() {
        @Override
        public int compare(String a, String b) {
            return b.compareTo(a);
        }
    });
The static utility method Collections.sort accepts a list and a comparator in order to sort the elements of the given list. You often find yourself creating anonymous comparators and pass them to the sort method.

Instead of creating anonymous objects all day long, Java 8 comes with a much shorter syntax, lambda expressions:
    Collections.sort(names, (String a, String b) -> {
        return b.compareTo(a);
    });

As you can see the code is much shorter and easier to read. But it gets even shorter:
    Collections.sort(names, (String a, String b) -> b.compareTo(a));

For one line method bodies you can skip both the braces {} and the return keyword. But it gets even more shorter:
    Collections.sort(names, (a, b) -> b.compareTo(a));
The java compiler is aware of the parameter types so you can skip them as well. Let's dive deeper into how lambda expressions can be used in the wild.

201: What is the difference between assigning null to object and just declaration
https://stackoverflow.com/questions/16415848/java-what-is-the-difference-between-assigning-null-to-object-and-just-declarati

    For instance, local variables don't have default values in which case you will have to assign null manually, where as in case of instance variables assigning null is redundant since instance variables get default values.
